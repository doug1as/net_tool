#!/usr/bin/env python

import os
import sys
import json
import time
import getpass
import platform
import mylibs.color as color
from netmiko import ConnectHandler, redispatch
from netmiko import SSHDetect
from datetime import datetime
from alive_progress import alive_bar


class Auxiliary:
	"""
	A class with aux methods, for help other classes.

	...

	Attributes
	----------
	None attributes are necessary.

	Methods
	-------
	# Print Methods #
	info_message(trigger):
		Print information about the process.

	# Aux Methods #
	make_report_directory()
		Make directory for store report archives.

	make_output_log_file()
		Open or close .csv log file for store report.

	discover_ssh_file_path()
		Discover full path of ssh config personalized file, this is an static method.

	get_credentials()
		Ask for TACACS credentials to access elements.

	get_hostname()
		Ask for HOSTNAME to access elements in menu..
	"""

	# Magic dunder methods
	def __init__(self, device, connection):
		"""
		Constructs all the necessary attributes for the Auxiliary object.

		Parameters
		----------
			device : dict
				Mainly contain device_type, host, user, pass, ssh_config_file, maybe others
		"""

		self.device = device
		self.connection = connection

	def __repr__(self):
		"""
		Represent all the necessary attributes for the Element object in better format.

		Parameters
		----------
		"""

		return '{DEVICE TYPE: ' + self.device['device_type'] + ' | ' + 'HOSTNAME/IP: ' + self.device['host'].upper() + '}'

	def __str__(self):
		"""
		Print all the necessary attributes for the Element object in better format.

		Parameters
		----------
		"""

		if self.device['device_type'] != 'extreme_telnet':
			return "Device Type: {} | Host: {} | Config File For SSH: {}".format(
				self.device['device_type'],
				self.device['host'].upper(),
				self.device['ssh_config_file']
				)
		else:
			return "Device Type: {} | Host: {} | Config File For SSH: {}".format(
				self.device['device_type'],
				self.device['host'].upper(),
				'Telnet Connection'
				)

	# Print Methods
	def info_message(self, trigger):
		"""
		Prints the informational messages during the process.
		If the argument 'trigger' is passed correctly, some message will send for output.

		Parameters
		----------
			trigger : str
				Selector for informational message !

		Returns
		-------
		str
		"""

		# Hostname variable for print outputs
		hostname = self.connection.find_prompt()[0:len(self.connection.find_prompt())-1]

		if trigger == 'conn_try':
			print("")
			print("#" * 126)
			print('   Trying Establish {0} to {1} ........'.format(
				str(color.prRed('Connection')),
				str(color.prGreen(hostname.upper()))
				)
				)
			return 'OK'

		elif trigger == 'conn_ok':
			print('   Connection {0} With {1} ........'.format(
				str(color.prGreen('Established')),
				str(color.prGreen(hostname.upper()))
				)
				)
			print("#" * 126)
			return 'OK'

		elif trigger == 'wait':
			print('-' * 126)
			print('   Wait a Moment Please, Identifying {0} Number of Slots, Interfaces and Hardware Model !'.format(
				str(color.prYellow(hostname.upper()))
				)
				)
			print('#' * 126)
			return 'OK'

		elif trigger == 'collect_interface_report_done':
			print("---> Number of Slots on {}: {}".format(
				hostname.upper(),
				str(color.prGreen('Done!'))
				)
				)
			time.sleep(0.5)
			#
			print("---> Number of Interfaces on {}: {}".format(
				hostname.upper(),
				str(color.prGreen('Done!'))
				)
				)
			time.sleep(0.5)
			#
			print("---> Hardware Model on {}: {}".format(
				hostname.upper(),
				str(color.prGreen('Done!'))
				)
				)
			time.sleep(0.5)
			return 'OK'

		elif trigger == 'start':
			print('#' * 126)
			print('   Starting Collect on {0} for Generate Report ........'.format(
				str(color.prGreen(hostname.upper()))
				)
				)
			print('#' * 126)
			return 'OK'

		elif trigger == 'done':
			print("")
			print('-' * 126)
			print('   {0} ........'.format(
				str(color.prGreen('Done !'))
				)
				)
			print("#" * 126)
			return 'OK'

		else:
			print(str(color.prRed('You informed wrong trigger for this method !'.upper())))
			return 'NOK'

	# Aux Methods
	@staticmethod
	def make_report_directory():
		"""
		Make directory for store reports generated by this script.

		Parameters
		----------

		Returns
		-------
		str
		"""

		# Variables
		report_dir_name = 'REPORTS'

		# Changing to script directory first
		os.chdir(os.path.dirname(__file__))

		# Getting Current Directory and Creating Reports Directory
		current_directory = os.getcwd()

		# Getting home directory for user, find correct ssh config file for respective jump server and create REPORTS folder
		operational_system = platform.system()

		if operational_system == 'Windows':
			# Current date and time for creating directory
			now = datetime.today()
			date_directory = now.strftime("%Y-%m-%d")
			# Full path
			path = current_directory + '\\' + report_dir_name + '\\' + date_directory

		elif operational_system == 'Linux':
			# Current date and time for creating directory
			now = datetime.today()
			date_directory = now.strftime("%Y-%m-%d")
			# Full path
			path = current_directory + '/' + report_dir_name + '/' + date_directory

		else:
			path = ''
			print("This Operating System Isn't Supported By This Script !")
			exit()

		print("")
		print('#' * 126)
		# Creating REPORTS directory
		if not os.path.exists(path):
			print(str(color.prRed("   Reports directory don't exist, i'll create for you!")))
			print(str(color.prYellow("   Creating ...")))
			time.sleep(2)
			print(str(color.prYellow("   Changing for him!")))
			time.sleep(1)
			os.makedirs(path)
			os.chdir(path)
			print(str(color.prGreen('   Done!')))
			print(str(color.prGreen('   Path of created directory: ')) + path)
			print('#' * 126)
			time.sleep(1)
			return path

		else:
			print(str(color.prYellow("   Reports directory already exist, changing for him!")))
			os.chdir(path)
			print(str(color.prGreen('   Done!')))
			print('#' * 126)
			time.sleep(1)
			return path

	@staticmethod
	def make_output_log_file(trigger, log_to_close=''):
		"""
		Make .csv log file for store reports.

		Parameters
		----------
			trigger : str
				Selector for 'open' or 'close' log file !
			log_to_close: io.TextIOWrapper
				For avoid UnboundLocalError

		Returns
		-------
		io.TextIOWrapper for open trigger
		str for close trigger
		"""

		if trigger == 'open':
			# Current date and time for creating .log file
			now = datetime.today()
			text_date_hour = now.strftime("%Y%m%d-%H%M%S")
			output_log = open("{}--OUTPUT.csv".format(text_date_hour), "a")
			return output_log, 'OK'
		elif trigger == 'close':
			log_to_close.close()
			return log_to_close, 'OK'
		else:
			return 'NOK'

	@staticmethod
	def get_credentials():
		"""
		Ask for TACACS credentials to access elements.

		Parameters
		----------
			None parameters are necessary.

		Returns
		-------
		str
		"""

		print('#' * 60)
		username = str(input("   Inform your TACACS user: "))
		password = getpass.getpass("   Inform your TACACS password: ")
		print('#' * 60)

		return username, password

	@staticmethod
	def discover_ssh_file_path(jump_server):
		"""
		Discover full path of ssh config personalized file.

		Parameters
		----------
			jump_server : str
				Selector for personalized ssh config file, vivo1 or vivo2 !

		Returns
		-------
		str
		"""

		# Getting home directory for user, find correct ssh config file for respective jump server and create REPORTS folder
		operational_system = platform.system()

		if operational_system == 'Windows':
			# SSH file location
			ssh_file_location = os.path.expanduser("~\\.ssh\\")
		elif operational_system == 'Linux':
			# SSH file location
			ssh_file_location = os.path.expanduser("~/.ssh/")
		else:
			ssh_file_location = ''
			print("This Operating System Isn't Supported By This Script !")
			exit()

		if jump_server == 'vivo1':
			ssh_config = ssh_file_location + 'config-vivo1'

		elif jump_server == 'vivo2':
			ssh_config = ssh_file_location + 'config-vivo2'

		else:
			ssh_config = ssh_file_location + 'config'

		return ssh_config

	@staticmethod
	def get_hostname():
		"""
		Ask for HOSTNAME to access elements in menu.

		Parameters
		----------
			None parameters are necessary.

		Returns
		-------
		str
		"""

		print('#' * 60)
		hostname = str(input("   Inform Device Hostname: "))
		print('#' * 60)

		return hostname


class NetworkElement:
	"""
	A class to represent a network element.

	...

	Attributes
	----------
	device : dict
		Mainly contain device_type, host, user, pass, ssh_config_file, maybe others.

	Methods
	-------
	# Equipment Methods #
	device_connect()
		Discover best match for device_type attribute for netmiko connections, this is an static method.

	check_qtde_slots()
		Return a list with number of slots, like: [1,2,4,5].

	check_qtde_slot_interfaces()
		Return a nested dict with type of interfaces and how many.

	check_qtde_total_interfaces()
		Detect how many interfaces network element has.

	check_hardware_model()
		Detect hardware model for network element.

	check_firmware_version()
		Detect firmware version for network element.

	check_status_ports()
		Count how many interfaces are up and their speeds.

	check_serial_number()
		Detect serial number for network element.

	interface_report()
		Make .csv report file with interfaces information, status, media type and so on.

	make_report_snmp_syslog()
		Make .csv report file with snmp and syslog servers.

	"""

	# Magic dunder methods
	def __init__(self, device):
		"""
		Constructs all the necessary attributes for the NetworkElement object.

		Parameters
		----------
			device : dict
				Mainly contain device_type, host, user, pass, ssh_config_file, maybe others
		"""

		self.device = device
		self.connection = self.device_connect()

	def __repr__(self):
		"""
		Represent all the necessary attributes for the Element object in better format.

		Parameters
		----------
		"""

		return '{DEVICE TYPE: ' + self.device['device_type'] + ' | ' + 'HOSTNAME/IP: ' + self.device['host'].upper() + '}'

	def __str__(self):
		"""
		Print all the necessary attributes for the Element object in better format.

		Parameters
		----------
		"""

		if self.device['device_type'] != 'extreme_telnet':
			return "Device Type: {} | Host: {} | Config File For SSH: {}".format(
				self.device['device_type'],
				self.device['host'].upper(),
				self.device['ssh_config_file']
				)
		else:
			return "Device Type: {} | Host: {} | Config File For SSH: {}".format(
				self.device['device_type'],
				self.device['host'].upper(),
				'Telnet Connection'
				)

	# Equipment Methods
	def device_connect(self):
		"""
		Discover best match for device_type attribute for netmiko connections.
		+- 45s

		Parameters
		----------

		Returns
		-------
		Netmiko ConnectHandler Object
		"""

		print("#" * 126)
		print('   Trying {0} Device Type For Network Automation In {1} ........'.format(
			str(color.prRed('Detect')),
			str(color.prGreen(self.device['host'].upper()))
		)
		)

		if self.device['device_type'] == 'telnet':

			# Reseting device type if they passed with wrong type
			self.device['device_type'] = 'extreme_telnet'

			# Excluding ssh parameter for telnet access
			self.device.pop('ssh_config_file')

			# Connecting to device
			connection = ConnectHandler(**self.device)

			print('   Device Type {0} On {1} ........'.format(
				str(color.prGreen('Detected')),
				str(color.prGreen(self.device['host'].upper()))
			)
			)
			print("#" * 126)

			# Return 'extreme_telnet' for telnet connection instead of ssh
			return connection

		else:

			if self.device['ssh_config_file'] == 'vivo2':

				# Reseting device type if they passed with wrong type
				self.device['device_type'] = 'autodetect'

				# Parameters for ssh proxy server
				self.device['ssh_config_file'] = Auxiliary.discover_ssh_file_path(self.device['ssh_config_file'])

				# Auto detecting device type
				guesser = SSHDetect(**self.device)
				self.device['device_type'] = guesser.autodetect()

				# Connecting to device
				connection = ConnectHandler(**self.device)

				print('   Device Type {0} On {1} ........'.format(
					str(color.prGreen('Detected')),
					str(color.prGreen(self.device['host'].upper()))
				)
				)
				print("#" * 126)

				# Return Netmiko ConnectHandler object
				return connection

			elif self.device['ssh_config_file'] == 'vivo1':

				# Storing hostname for redispath connection
				device_type = self.device['device_type']
				hostname = self.device['host']

				# Reseting device type if they passed with wrong type
				self.device['device_type'] = 'linux'
				self.device['host'] = '200.204.1.4'

				# Excluding ssh parameter for redispath access
				self.device.pop('ssh_config_file')

				# Connecting to jump server via ssh
				connection = ConnectHandler(**self.device)
				# print(connection.find_prompt())

				# Auto detecting device type
				# guesser = SSHDetect(**self.device)
				# self.device['device_type'] = guesser.autodetect()
				command = f"ssh " + hostname + "\n"
				connection.write_channel(command)
				time.sleep(10)
				connection.write_channel(connection.password + '\n')
				time.sleep(10)
				# corrigir identificação para seleção correta de drivers, show "verssion" e etc ...
				redispatch(connection, device_type=device_type)
				# print(connection.device_type)
				####################################################

				print('   Device Type {0} On {1} ........'.format(
					str(color.prGreen('Detected')),
					str(color.prGreen(hostname.upper()))
				)
				)
				print("#" * 126)

				# Return Netmiko ConnectHandler object
				return connection

	def check_qtde_slots(self):
		"""
		1 - Connect in element.
		2 - Select type of element (Extreme, Brocade, HP, and so on).
		3 - Return a list with number of slots, like: [1,2,4,5] ...
		+- 10s

		Parameters
		----------

		Returns
		-------
		list
		"""

		# Try/Except Block
		try:

			# Brocade NOS Section
			if (self.device['device_type'] == 'brocade_nos') or (self.connection.device_type == 'brocade_nos'):
				# Array/List with Slots Numbers
				all_slots = []

				# Lopping for maximum slots possibilities
				for slot in range(1, 3):

					# Sending Command(s)
					cli_slot = 'show chassis rbridge-id ' + str(slot)
					cli_check_slot = self.connection.send_command(cli_slot)
					cli_vcs_mode = 'show vcs | i "Config Mode"'
					cli_check_vcs_mode = self.connection.send_command(cli_vcs_mode)

					# Check Qtde Modules
					if 'Rbridge-id does not exist' in cli_check_slot:
						continue

					elif 'syntax error: unknown argument' in cli_check_slot:

						if 'Local-Only' in cli_check_vcs_mode:
							# Sending Command(s)
							cli_slot = 'show chassis'
							cli_check_slot = self.connection.send_command(cli_slot)

							if len(cli_check_slot) > 0:
								all_slots.append(slot)
								break

					elif len(cli_check_slot) > 0:
						all_slots.append(slot)

					else:
						print("Problem with slots detection, please verify !")

				# Returning a list of all rbridges, like: [1,2,3,4] or not sequential, like: [1,2,7,8]
				return all_slots

			# Cisco NXOS Section
			elif (self.device['device_type'] == 'cisco_nxos') or (self.connection.device_type == 'cisco_nxos'):
				# Array/List with Slots Numbers
				all_slots = []

				# Model variable for compare type of necessary loop
				hardware_model = self.check_hardware_model()

				# Lopping for maximum slots possibilities
				for slot in range(1, 5):

					# Checking if slot is in some dict key
					if str(slot) in hardware_model.keys():

						# Checking if is chassis
						if '9504' in hardware_model[str(slot)]:

							# 9504 has maximum 4 slots.
							if slot > 4:
								continue

							# Sending Command(s)
							cli_slot = 'show module ' + str(slot)
							cli_check_slot = self.connection.send_command(cli_slot)

							# Check Qtde Modules
							if len(cli_check_slot) == 0:
								continue
							elif 'ERROR: invalid module slot' in cli_check_slot:
								continue
							elif len(cli_check_slot) > 0:
								all_slots.append(slot)
							else:
								print("[check_qtde_slots - NXOS]Problem with slots detection, please verify !")

						elif '93180' in hardware_model[str(slot)]:

							# 93180 has only one slot (pizza box).
							if slot > 1:
								continue

							# Sending Command(s)
							cli_slot = 'show module ' + str(slot)
							cli_check_slot = self.connection.send_command(cli_slot)

							# Check Qtde Modules
							if len(cli_check_slot) == 0:
								continue
							elif 'ERROR: invalid module slot' in cli_check_slot:
								continue
							elif len(cli_check_slot) > 0:
								all_slots.append(slot)
							else:
								print("[check_qtde_slots - NXOS]Problem with slots detection, please verify !")

						else:
							print("Problem with qtde slots detection, please verify !")

				# Returning a list of all modules detected, like: [1,2,3,4] or not sequential, like: [1,2,7,8]
				return all_slots

			# HP COMWARE Section
			elif self.device['device_type'] == 'hp_comware' or (self.connection.device_type == 'hp_comware'):
				# Array/List with Slots Numbers
				all_slots = []

				# Lopping for maximum slots possibilities
				for slot in range(0, 11):

					# Sending Command(s)
					cli_slot = 'display device manuinfo slot ' + str(slot) + ' | i NAME'
					cli_check_slot = self.connection.send_command(cli_slot)

					# Check Qtde Modules
					if ('Wrong parameter' in cli_check_slot) or ('Fabric Module' in cli_check_slot):
						continue
					elif len(cli_check_slot) > 0:
						all_slots.append(slot)
					else:
						print("Problem with slots detection, please verify !")

				# Returning a list of all slots, like: [1,2,3,4] or not sequential, like: [1,2,7,8]
				return all_slots

			else:
				return "Device Type Don't Detected !"

		except Exception as e:
			print('\n{}'.format(
				str(color.prRed('*****--------------------<<<<<<<<<< BEGIN >>>>>>>>>>--------------------*****'))))
			print("Oops!", sys.exc_info()[0], " in ", self.device['host'].upper(), "occurred.")
			for erro in sys.exc_info():
				print(erro)
			print(
				type(e).__name__,  # Type of Error
				__file__,  # File Path
				e.__traceback__.tb_lineno  # Line Error
			)
			print('{}'.format(
				str(color.prRed('*****--------------------<<<<<<<<<< *END* >>>>>>>>>>--------------------*****\n'))))

	def check_qtde_interfaces_slots(self):
		"""
		1 - Connect in element.
		2 - Select type of element (Extreme, Brocade, HP, and so on).
		3 - Return a tuple with number of interfaces 10GB, 40GB and 100GB per slot, like:
			({'1': 48, '2': 48}, {'1': 4, '2': 4}, {'1': 0, '2': 0}) ...
		+- 25s

		Parameters
		----------

		Returns
		-------
		tuple or dict
		"""

		# Main Try/Except Block
		try:

			# Dict for return
			qtde_interfaces = {
				'qtde_interfaces_10': {},
				'qtde_interfaces_100': {},
			}

			# Brocade NOS Section
			if (self.device['device_type'] == 'brocade_nos') or (self.connection.device_type == 'brocade_nos'):
				# Variables
				qtde_slots = self.check_qtde_slots()

				# Lopping for maximum slots possibilities
				for slot in qtde_slots:

					# Sending Command(s)
					cli_chassis = 'show chassis rbridge-id ' + str(slot) + ' | i "Chassis Name"'
					cli_check_chassis = self.connection.send_command(cli_chassis)
					cli_vcs_mode = 'show vcs | i "Config Mode"'
					cli_check_vcs_mode = self.connection.send_command(cli_vcs_mode)

					# Check Qtde Modules
					if 'syntax error: unknown argument' in cli_check_chassis:

						if 'Local-Only' in cli_check_vcs_mode:
							# Sending Command(s)
							cli_chassis = 'show chassis | i "Chassis Name"'
							cli_check_chassis = self.connection.send_command(cli_chassis)
						else:
							print("Problem in check_qtde_interfaces_slots Brocade NOS Section")

					# Check Qtde Interfaces
					if 'VDX6940-144S' in cli_check_chassis:

						# 10GB --> Always has the same quantity
						qtde_interfaces['qtde_interfaces_10'][str(slot)] = 96  # Fiber
						qtde_interfaces['qtde_interfaces_100'][str(slot)] = 0

						# Looping trough interfaces 40GB
						for port in range(1, 5):

							# Variables for Command(s)
							cli_breakout = 'show running-config hardware port-group ' + str(slot) + '/0/' + str(port)

							# Sending Command(s)
							cli_check_100g = self.connection.send_command(cli_breakout)

							if 'mode 100g' in cli_check_100g:
								qtde_interfaces['qtde_interfaces_100'][str(slot)] += 1


					elif 'VDX6740' in cli_check_chassis:
						qtde_interfaces['qtde_interfaces_10'][str(slot)] = 48  # Fiber
						qtde_interfaces['qtde_interfaces_100'][str(slot)] = 0

					else:
						print("Problem with qtde interfaces detection, please verify !")

				# Returning a nested dictionary of all slots: qtde interface,
				# like: Dict = { 'Dict1': {'dic1_key1': 'dic1_value1', 'dic1_key2': 'dic1_value2'},
				#          		 'Dict2': {'dic2_key1': 'dic2_value1', 'dic2_key2': 'dic2_value2'}}
				return qtde_interfaces

			# Cisco NXOS Section
			if (self.device['device_type'] == 'cisco_nxos') or (self.connection.device_type == 'cisco_nxos'):
				# Variables
				qtde_slots = self.check_qtde_slots()

				# Model variable for compare type of necessary loop
				hardware_model = self.check_hardware_model()

				# Lopping for maximum slots possibilities
				for slot in qtde_slots:

					# Checking if is chassis
					if ('9504' in hardware_model[str(slot)]) or ('93180' in hardware_model[str(slot)]):

						# Sending Command(s)
						cli_slot = 'show module ' + str(slot) + ' | json'
						cli_check_slot = self.connection.send_command(cli_slot)

						# Converting str output to dict
						cli_check_slot_dict = json.loads(cli_check_slot)

						# Check Qtde Interfaces
						if '48x10/25G + 4x40/100G' in cli_check_slot_dict['TABLE_modinfo']['ROW_modinfo']['modtype']:
							qtde_interfaces['qtde_interfaces_10'][str(slot)] = 48  # Fiber
							qtde_interfaces['qtde_interfaces_100'][str(slot)] = 4  # Fiber
						elif '48x10/25G + 6x40/100G' in cli_check_slot_dict['TABLE_modinfo']['ROW_modinfo']['modtype']:
							qtde_interfaces['qtde_interfaces_10'][str(slot)] = 48  # Fiber
							qtde_interfaces['qtde_interfaces_100'][str(slot)] = 6  # Fiber
						elif '36x40/100G Ethernet Module' in cli_check_slot_dict['TABLE_modinfo']['ROW_modinfo']['modtype']:
							qtde_interfaces['qtde_interfaces_100'][str(slot)] = 36  # Fiber
						else:
							print("Problem with qtde interfaces detection, please verify !")


					else:
						print("Problem with qtde interfaces detection, please verify !")

				# Returning a nested dictionary of all slots: qtde interface,
				# like: Dict = { 'Dict1': {'dic1_key1': 'dic1_value1', 'dic1_key2': 'dic1_value2'},
				#          		 'Dict2': {'dic2_key1': 'dic2_value1', 'dic2_key2': 'dic2_value2'}}
				return qtde_interfaces

			# HP COMWARE Section
			if (self.device['device_type'] == 'hp_comware')  or (self.connection.device_type == 'hp_comware'):
				# Variables
				qtde_slots = self.check_qtde_slots()

				# Model variable for compare type of necessary loop
				hardware_model = self.check_hardware_model()

				# Lopping for maximum slots possibilities
				for slot in qtde_slots:

					# Checking if is chassis
					if '5900AF-48XG-4QSFP+' in hardware_model[str(slot)]:

						# Check Qtde Interfaces
						qtde_interfaces['qtde_interfaces_10'][str(slot)] = 48  # Fiber
						qtde_interfaces['qtde_interfaces_100'][str(slot)] = 0  # Fiber

					else:
						print("Problem with qtde interfaces detection in check_qtde_interfaces_slots HP section, please verify !")

				# Returning a nested dictionary of all slots: qtde interface,
				# like: Dict = { 'Dict1': {'dic1_key1': 'dic1_value1', 'dic1_key2': 'dic1_value2'},
				#          		 'Dict2': {'dic2_key1': 'dic2_value1', 'dic2_key2': 'dic2_value2'}}
				return qtde_interfaces

		except Exception as e:
			print('\n{}'.format(
				str(color.prRed('*****--------------------<<<<<<<<<< BEGIN >>>>>>>>>>--------------------*****'))))
			print("Oops!", sys.exc_info()[0], " in ", self.device['host'].upper(), "occurred.")
			for erro in sys.exc_info():
				print(erro)
			print(
				type(e).__name__,  # Type of Error
				__file__,  # File Path
				e.__traceback__.tb_lineno  # Line Error
			)
			print('{}'.format(
				str(color.prRed('*****--------------------<<<<<<<<<< *END* >>>>>>>>>>--------------------*****\n'))))

	def check_qtde_total_interfaces(self):
		"""
		Count how many interfaces element has, independent of type.
		+- 20s

		Parameters
		----------

		Returns
		-------
		int
		"""

		# Main Try/Except Block
		try:
			# Retrieving nested dict with per type totals
			interfaces = self.check_qtde_interfaces_slots()

			# Variable for total interfaces count
			total_interfaces = 0

			# USE RECURSION TO LOOP THROUGH ALL NESTED DICTIONARY VALUES
			for key, value in interfaces.items():
				if type(value) is dict:
					for nested_key, nested_value in value.items():
						total_interfaces += nested_value
				else:
					continue

			return total_interfaces

		except Exception as e:
			print('\n{}'.format(
				str(color.prRed('*****--------------------<<<<<<<<<< BEGIN >>>>>>>>>>--------------------*****')))
			)
			print("Oops!", sys.exc_info()[0], " in ", self.device['host'].upper(), "occurred.")
			for erro in sys.exc_info():
				print(erro)
			print(
				type(e).__name__,  # Type of Error
				__file__,  # File Path
				e.__traceback__.tb_lineno  # Line Error
			)
			print('{}'.format(
				str(color.prRed('*****--------------------<<<<<<<<<< *END* >>>>>>>>>>--------------------*****\n')))
			)

	def check_hardware_model(self):
		"""
		1 - Connect in element.
		2 - Select type of element (Extreme, Brocade, HP, and so on).
		3 - Return a dict with hardware models,
			like: {'1': 'VDX670', '2': 'VDX6740', '3': 'VDX670T-1G', 'N...': 'VDX670T-1G'} ...
		+- 18s

		Parameters
		----------

		Returns
		-------
		dict
		"""

		# Main Try/Except Block
		try:

			# Brocade NOS Section
			if (self.device['device_type'] == 'brocade_nos') or (self.connection.device_type == 'brocade_nos'):
				# Variables
				qtde_slots = self.check_qtde_slots()
				hardware_model = {}  # Dictionary with Chassis/Slot Models {'1': 'MODEL'}

				# Lopping for maximum slots possibilities
				for slot in qtde_slots:

					# Sending Command(s)
					cli_chassis = 'show chassis rbridge-id ' + str(slot) + ' | i "Chassis Name"'
					cli_check_chassis = self.connection.send_command(cli_chassis)
					cli_vcs_mode = 'show vcs | i "Config Mode"'
					cli_check_vcs_mode = self.connection.send_command(cli_vcs_mode)

					# Check Qtde Modules
					if 'syntax error: unknown argument' in cli_check_chassis:

						if 'Local-Only' in cli_check_vcs_mode:
							# Sending Command(s)
							cli_chassis = 'show chassis | i "Chassis Name"'
							cli_check_chassis = self.connection.send_command(cli_chassis)
						else:
							print("Problem in check_qtde_interfaces_slots Brocade NOS Section")
					# Populate array of models
					hardware_model[str(slot)] = cli_check_chassis[14:]

				# Returning a dict of hardware model,
				# like: {'1': 'VDX670', '2': 'VDX6740', '3': 'VDX670T-1G', 'N...': 'VDX670T-1G'}
				return hardware_model

			# Cisco NXOS Section
			elif (self.device['device_type'] == 'cisco_nxos') or (self.connection.device_type == 'cisco_nxos'):
				# Variables
				hardware_model = {}  # Dictionary with Chassis/Slot Models {'1': 'MODEL'}

				# Sending Command(s)
				cli_chassis = 'show version'
				cli_check_chassis = self.connection.send_command(cli_chassis, use_textfsm=True)

				# Check if is NEXUS chassis
				if 'C9504' in cli_check_chassis[0]['platform']:
					hardware_model['1'] = cli_check_chassis[0]['platform']
					hardware_model['2'] = cli_check_chassis[0]['platform']
					hardware_model['3'] = cli_check_chassis[0]['platform']
					hardware_model['4'] = cli_check_chassis[0]['platform']

				elif '93180YC' in cli_check_chassis[0]['platform']:
					hardware_model['1'] = cli_check_chassis[0]['platform']

				else:
					print("Problem with check hardware model detection, please verify !")

				# Returning a dict of hardware model, like: {'1': 'x460-48t', 'N...': 'x240-24x'}
				return hardware_model

			# HP COMWARE Section
			elif self.device['device_type'] == 'hp_comware' or (self.connection.device_type == 'hp_comware'):
				# Variables
				qtde_slots = self.check_qtde_slots()
				hardware_model = {}  # Dictionary with Chassis/Slot Models {'1': 'MODEL'}

				# Lopping for maximum slots possibilities
				for slot in qtde_slots:

					# Sending Command(s)
					cli_chassis = 'display device manuinfo slot ' + str(slot) + ' | i NAME'
					cli_check_chassis = self.connection.send_command(cli_chassis)

					if 'Wrong parameter' in cli_check_chassis:
						continue
					elif '5900AF-48XG-4QSFP+' in cli_check_chassis:
						hardware_model[str(slot)] = '5900AF-48XG-4QSFP+'
					elif 'A5500-48G-4SFP' in cli_check_chassis:
						hardware_model[str(slot)] = 'A5500-48G-4SFP'
					else:
						print("Problem with Hardware detection, please verify !")

				# Returning a dict of hardware model, like: {'1': 'x460-48t', 'N...': 'x240-24x'}
				return hardware_model

		except Exception as e:
			print('\n{}'.format(
				str(color.prRed('*****--------------------<<<<<<<<<< BEGIN >>>>>>>>>>--------------------*****')))
			)
			print("Oops!", sys.exc_info()[0], " in ", self.device['host'].upper(), "occurred.")
			for erro in sys.exc_info():
				print(erro)
			print(
				type(e).__name__,  # Type of Error
				__file__,  # File Path
				e.__traceback__.tb_lineno  # Line Error
			)
			print('{}'.format(
				str(color.prRed('*****--------------------<<<<<<<<<< *END* >>>>>>>>>>--------------------*****\n')))
			)

	def check_firmware_version(self):
		"""
		1 - Connect in element.
		2 - Select type of element (Extreme, Brocade, HP, and so on).
		3 - Return a string with firmware version, like: 'nos 7.0.2b', and so on ...
		+- 2s

		Parameters
		----------

		Returns
		-------
		str
		"""

		# Main Try/Except Block
		try:

			# Brocade NOS Section
			if (self.device['device_type'] == 'brocade_nos') or (self.connection.device_type == 'brocade_nos'):
				# Sending Command(s)
				cli_switch = 'show version | i Firmware'
				cli_check_switch = self.connection.send_command(cli_switch)

				# Variables
				current_version = cli_check_switch.split()[-1]

				# Returning string with firmware version, like: 'nos 7.0.2b'
				return current_version

			# Cisco NXOS Section
			elif (self.device['device_type'] == 'cisco_nxos') or (self.connection.device_type == 'cisco_nxos'):
				# Sending Command(s)
				cli_switch = 'show version'
				cli_check_switch = self.connection.send_command(cli_switch, use_textfsm=True)

				# Variables
				current_version = cli_check_switch[0]['os']

				# Returning string with firmware version, like: 'nos 7.0.2b'
				return current_version


			# HP COMWARE Section
			elif self.device['device_type'] == 'hp_comware' or (self.connection.device_type == 'hp_comware'):
				# Sending Command(s)
				cli_switch = 'display version | i "Boot image version"'
				cli_check_switch = self.connection.send_command(cli_switch)

				# Variables
				current_version = " ".join(cli_check_switch.split()[-3:])

				# Returning string with firmware version, like: 'nos 7.0.2b'
				return current_version


			else:
				return "Device Type Don't Detected !"

		except Exception as e:
			print('\n{}'.format(
				str(color.prRed('*****--------------------<<<<<<<<<< BEGIN >>>>>>>>>>--------------------*****')))
			)
			print("Oops!", sys.exc_info()[0], " in ", self.device['host'].upper(), "occurred.")
			for erro in sys.exc_info():
				print(erro)
			print(
				type(e).__name__,  # Type of Error
				__file__,  # File Path
				e.__traceback__.tb_lineno  # Line Error
			)
			print('{}'.format(
				str(color.prRed('*****--------------------<<<<<<<<<< *END* >>>>>>>>>>--------------------*****\n')))
			)

	def check_status_ports(self):
		"""
		1 - Connect in element.
		2 - Select type of element (Extreme, Brocade, HP, and so on).
		3 - Return a dict with how many interfaces are up and their speeds ...

		Parameters
		----------

		Returns
		-------
		dict
		"""

		# Main Try/Except Block
		try:
			# Instance of Auxiliary class
			aux = Auxiliary(self.device, self.connection)

			# Variables for count status ports
			ports_in_use = 0
			ports_down = 0
			ports_admin_down = 0
			oper_status_1gb = 0
			oper_status_10gb = 0
			oper_status_100gb = 0

			# Variable for show hostname in alive bar
			hostname_bar = self.connection.find_prompt()[0:len(self.connection.find_prompt())-1]

			# Brocade NOS Section
			if (self.device['device_type'] == 'brocade_nos') or (self.connection.device_type == 'brocade_nos'):

				# "Loading" message
				aux.info_message('wait')

				# Returning a list of all slots, like: [1,2,3,4] or not sequential, like: [1,2,7,8]
				qtde_slots = self.check_qtde_slots()

				# Returning a dictionary of all slots and qtde interface,
				interfaces = self.check_qtde_interfaces_slots()

				# Populating variables
				qtde_interfaces_10 = interfaces['qtde_interfaces_10']
				qtde_interfaces_100 = interfaces['qtde_interfaces_100']

				# Returning a dictionary of all Models,
				# like: {'1': 'MODEL', '2': 'MODEL', '3': 'MODEL', '4': 'MODEL'}
				# or not sequential, like: {'1': 'MODEL', '2': 'MODEL', '7': 'MODEL', '8': 'MODEL'}
				check_model = self.check_hardware_model()

				# "Done" message
				aux.info_message('collect_interface_report_done')

				# Print message to inform about collect start
				aux.info_message('start')

				# Variables for create loop commands
				# Sum of total slots
				sum_slots = 0
				for _ in qtde_slots:
					sum_slots += 1

				# Variables for create loop commands
				# 1GB/10GB Section sum interface
				sum_interfaces_10gb = 0
				for ports in qtde_interfaces_10:
					sum_interfaces_10gb += int(qtde_interfaces_10[ports])

				# Variables for create loop commands
				# 100GB Section sum interfaces
				sum_interfaces_100gb = 0
				for ports in qtde_interfaces_100:
					sum_interfaces_100gb += int(qtde_interfaces_100[ports])

				# Variables for create loop commands
				# Sum of total interfaces possibilities
				sum_interfaces = sum_interfaces_10gb
				sum_interfaces += sum_interfaces_100gb

				# Section looping commands
				# Default setting of alive_progress as alive_bar imported for all ports
				with alive_bar(sum_interfaces, bar='smooth', spinner='waves', title=hostname_bar, length=55) as bar:

					# Lopping for maximum slots possibilities
					for slot in qtde_slots:

						# Checking hardware model for breakout interfaces
						
						# Looping trough interfaces 10GB
						# Checking hardware model
						if 'BR-VDX6740' in check_model[str(slot)]:

							# Looping trough interfaces 10GB
							for port in range(1, int(qtde_interfaces_10[str(slot)] + 1)):

								# Call after consuming one item, bar progress
								bar()

								# Variables for Command(s)
								cli_state = 'show interface te ' + str(slot) + '/0/' + str(port) + ' | i protocol'
								cli_speed = 'show interface te ' + str(slot) + '/0/' + str(port) + ' | i "LineSpeed Actual"'

								# Sending Command(s)
								cli_check_state = self.connection.send_command(cli_state)
								cli_check_speed = self.connection.send_command(cli_speed)

								# Admin Down section
								if 'admin down' in cli_check_state:
									ports_admin_down += 1
									continue

								# UP/Down section
								elif 'is up, line protocol is down (link protocol down)' in cli_check_state:
									ports_down += 1
									continue

								# Up section
								elif 'protocol is up (connected)' in cli_check_state:

									# 1Gb section
									if '1000 Mbit' in cli_check_speed:
										ports_in_use += 1
										oper_status_1gb += 1
										sum_interfaces_10gb -= 1
										continue

									# 10Gb section
									elif '10000 Mbit' in cli_check_speed:
										ports_in_use += 1
										oper_status_10gb += 1
										sum_interfaces_10gb -= 1
										continue

									# UNKNOWN UP Section
									else:
										print("Speed don't detected, please verify !")

								# UNKNOWN State Section
								else:
									print("Interface state don't detected, please verify: " + str(cli_state) + ":" + str(self.connection.host))


						# Looping trough interfaces 10GB and 100GB # VDX6940
						# Checking hardware model for breakout interfaces
						else:  # VDX6940

							# Looping trough interfaces 10GB
							for port in range(1, int(qtde_interfaces_10[str(slot)] + 1)):

								# Call after consuming one item, bar progress
								bar()

								# Variables for Command(s)
								cli_state = 'show interface te ' + str(slot) + '/0/' + str(port) + ' | i protocol'
								cli_speed = 'show interface te ' + str(slot) + '/0/' + str(port) + ' | i "LineSpeed Actual"'

								# Sending Command(s)
								cli_check_state = self.connection.send_command(cli_state)
								cli_check_speed = self.connection.send_command(cli_speed)

								# Admin Down section
								if 'admin down' in cli_check_state:
									ports_admin_down += 1
									continue

								# UP/Down section
								elif 'is up, line protocol is down (link protocol down)' in cli_check_state:
									ports_down += 1
									continue

								# Up section
								elif 'protocol is up (connected)' in cli_check_state:

									# 1Gb section
									if '1000 Mbit' in cli_check_speed:
										ports_in_use += 1
										oper_status_1gb += 1
										sum_interfaces_10gb -= 1
										continue

									# 10Gb section
									elif '10000 Mbit' in cli_check_speed:
										ports_in_use += 1
										oper_status_10gb += 1
										sum_interfaces_10gb -= 1
										continue

									# UNKNOWN UP Section
									else:
										print("Speed don't detected, please verify !")

								# UNKNOWN State Section
								else:
									print("Interface state don't detected, please verify: " + str(cli_state) + ":" + str(self.connection.host))

							# Checking if slot iterate is in interface type count dict
							if (str(slot) in qtde_interfaces_100.keys()) and (sum_interfaces_100gb > 0):

								# Looping trough interfaces 100GB
								# 100GB Section Group 1
								for port in range(97, 99):

									# Variables for Command(s)
									cli_state = 'show interface hu ' + str(slot) + '/0/' + str(port) + ' | i protocol'
									cli_speed = 'show interface hu ' + str(slot) + '/0/' + str(port) + ' | i "LineSpeed Actual"'

									# Sending Command(s)
									cli_check_state = self.connection.send_command(cli_state)
									cli_check_speed = self.connection.send_command(cli_speed)

									# Converted interfaces
									if "doesn't exist" in cli_check_state:
										continue

									# Converted interfaces
									elif len(cli_check_state) == 0:
										continue

									# Admin Down section
									if 'admin down' in cli_check_state:
										ports_admin_down += 1
										# Call after consuming one item, bar progress
										bar()
										continue

									# UP/Down section
									elif 'is up, line protocol is down (link protocol down)' in cli_check_state:
										ports_down += 1
										# Call after consuming one item, bar progress
										bar()
										continue

									# Up section
									elif 'protocol is up (connected)' in cli_check_state:

										# 100Gb section
										if '100000 Mbit' in cli_check_speed:
											ports_in_use += 1
											oper_status_100gb += 1
											sum_interfaces_100gb -= 1
											# Call after consuming one item, bar progress
											bar()
											continue

										# UNKNOWN UP Section
										else:
											print("Speed don't detected, please verify !")
											# Call after consuming one item, bar progress
											bar()

									# UNKNOWN State Section
									else:
										print("Interface state don't detected, please verify: " + str(cli_state) + ":" + str(self.connection.host))
										# Call after consuming one item, bar progress
										bar()

								# 100GB Section Group 2
								for port in range(103, 105):

									# Variables for Command(s)
									cli_state = 'show interface hu ' + str(slot) + '/0/' + str(port) + ' | i protocol'
									cli_speed = 'show interface hu ' + str(slot) + '/0/' + str(port) + ' | i "LineSpeed Actual"'

									# Sending Command(s)
									cli_check_state = self.connection.send_command(cli_state)
									cli_check_speed = self.connection.send_command(cli_speed)

									# Converted interfaces
									if "doesn't exist" in cli_check_state:
										continue

									# Converted interfaces
									elif len(cli_check_state) == 0:
										continue

									# Admin Down section
									elif 'admin down' in cli_check_state:
										ports_admin_down += 1
										# Call after consuming one item, bar progress
										bar()
										continue

									# UP/Down section
									elif 'is up, line protocol is down (link protocol down)' in cli_check_state:
										ports_down += 1
										# Call after consuming one item, bar progress
										bar()
										continue

									# Up section
									elif 'protocol is up (connected)' in cli_check_state:

										# 100Gb section
										if '100000 Mbit' in cli_check_speed:
											ports_in_use += 1
											oper_status_100gb += 1
											sum_interfaces_100gb -= 1
											# Call after consuming one item, bar progress
											bar()
											continue

										# UNKNOWN UP Section
										else:
											print("Speed don't detected, please verify !")
											# Call after consuming one item, bar progress
											bar()

									# UNKNOWN State Section
									else:
										print("Interface state don't detected, please verify: " + str(cli_state) + ":" + str(self.connection.host))
										# Call after consuming one item, bar progress
										bar()

				# Populating return dict				
				status_ports = {
					'ports_in_use': ports_in_use,
					'ports_down': ports_down,
					'ports_admin_down': ports_admin_down,
					'oper_status_1gb': oper_status_1gb,
					'oper_status_10gb': oper_status_10gb,
					'oper_status_100gb': oper_status_100gb,
					'ports_10gb_free': sum_interfaces_10gb,
					'ports_100gb_free': sum_interfaces_100gb,
				}

				return status_ports

			# Cisco NXOS Section
			if (self.device['device_type'] == 'cisco_nxos') or (self.connection.device_type == 'cisco_nxos'):

				# "Loading" message
				aux.info_message('wait')

				# Returning a list of all slots, like: [1,2,3,4] or not sequential, like: [1,2,7,8]
				qtde_slots = self.check_qtde_slots()

				# Returning a dictionary of all slots and qtde interface,
				interfaces = self.check_qtde_interfaces_slots()

				# Populating variables
				qtde_interfaces_10 = interfaces['qtde_interfaces_10']
				qtde_interfaces_100 = interfaces['qtde_interfaces_100']

				# Returning a dictionary of all Models,
				# like: {'1': 'MODEL', '2': 'MODEL', '3': 'MODEL', '4': 'MODEL'}
				# or not sequential, like: {'1': 'MODEL', '2': 'MODEL', '7': 'MODEL', '8': 'MODEL'}
				check_model = self.check_hardware_model()

				# "Done" message
				aux.info_message('collect_interface_report_done')

				# Print message to inform about collect start
				aux.info_message('start')

				# Variables for create loop commands
				# Sum of total slots
				sum_slots = 0
				for _ in qtde_slots:
					sum_slots += 1

				# Variables for create loop commands
				# 1GB/10Gb Section sum interfaces
				sum_interfaces_10gb = 0
				for ports in qtde_interfaces_10:
					sum_interfaces_10gb += int(qtde_interfaces_10[ports])

				# Variables for create loop commands
				# 100GB Section sum interfaces
				sum_interfaces_100gb = 0
				for ports in qtde_interfaces_100:
					sum_interfaces_100gb += int(qtde_interfaces_100[ports])

				# List for easy sum
				interfaces_for_sum = [
					sum_interfaces_10gb,
					sum_interfaces_100gb
				]

				# Variables for create loop commands
				# Sum of total interfaces possibilities
				sum_interfaces = 0
				for interface_count in interfaces_for_sum:
					sum_interfaces += interface_count

				# Section looping commands
				# Default setting of alive_progress as alive_bar imported for all ports
				with alive_bar(sum_interfaces, bar='smooth', spinner='waves', title=hostname_bar, length=55) as bar:

					# Lopping for maximum slots possibilities
					for slot in qtde_slots:

						# Checking if is chassis
						if ('9504' in check_model[str(slot)]) or ('93180' in check_model[str(slot)]):

							# Checking if slot iterate is in interface type count dict
							if str(slot) in qtde_interfaces_10.keys():
								# Looping trough interfaces 10GB
								for port in range(1, int(qtde_interfaces_10[str(slot)] + 1)):

									# Call after consuming one item, bar progress
									bar()

									# Variables for Command(s)
									cli_int = 'show interface eth ' + str(slot) + '/' + str(port) + ' | json'

									# Sending Command(s)
									cli_check_int = self.connection.send_command(cli_int)

									# Converting str output to dict
									cli_check_int_dict = json.loads(cli_check_int)

									# Admin Down section
									if 'down' in cli_check_int_dict["TABLE_interface"]["ROW_interface"]['admin_state']:
										ports_admin_down += 1
										continue

									# UP/Down section
									elif 'down' in cli_check_int_dict["TABLE_interface"]["ROW_interface"]['state']:
										ports_down += 1
										continue

									# Up section
									elif 'up' in cli_check_int_dict["TABLE_interface"]["ROW_interface"]['state']:

										# 10Gb section
										if '10000000' in cli_check_int_dict["TABLE_interface"]["ROW_interface"]['eth_bw']:
											ports_in_use += 1
											oper_status_10gb += 1
											sum_interfaces_10gb -= 1
											continue

										# 1Gb section
										elif '1000000' in cli_check_int_dict["TABLE_interface"]["ROW_interface"]['eth_bw']:
											ports_in_use += 1
											oper_status_1gb += 1
											sum_interfaces_10gb -= 1
											continue										
										

										# UNKNOWN UP Section
										else:
											print("Speed don't detected, please verify !")

							# Checking if slot iterate is in interface type count dict
							if str(slot) in qtde_interfaces_100.keys():

								# Nexus 9504 - N9K-X9736C-FX
								if (qtde_interfaces_100[str(slot)] == 36) and ('9504' in check_model[str(slot)]):

									# Looping trough interfaces 40GB/100GB - N9K-X9736C-FX
									for port in range(1, int(qtde_interfaces_100[str(slot)] + 1)):

										# Call after consuming one item, bar progress
										bar()

										# Variables for Command(s)
										cli_int = 'show interface eth ' + str(slot) + '/' + str(port) + ' | json'

										# Sending Command(s)
										cli_check_int = self.connection.send_command(cli_int)

										# Converting str output to dict
										cli_check_int_dict = json.loads(cli_check_int)

										# Admin Down section
										if 'down' in cli_check_int_dict["TABLE_interface"]["ROW_interface"]['admin_state']:
											ports_admin_down += 1
											continue

										# UP/Down section
										elif 'down' in cli_check_int_dict["TABLE_interface"]["ROW_interface"]['state']:
											ports_down += 1
											continue

										# Up section
										elif 'up' in cli_check_int_dict["TABLE_interface"]["ROW_interface"]['state']:

											# 100Gb section
											if '100000000' in cli_check_int_dict["TABLE_interface"]["ROW_interface"]['eth_bw']:
												ports_in_use += 1
												oper_status_100gb += 1
												sum_interfaces_100gb -= 1
												continue

											# UNKNOWN UP Section
											else:
												print("Speed don't detected, please verify !")

								# Nexus 9504 - N9K-X97160YC-EX
								elif (qtde_interfaces_100[str(slot)] == 4) and ('9504' in check_model[str(slot)]):
									# Looping trough interfaces 40GB/100GB - N9K-X97160YC-EX
									for port in range(49, 53):

										# Call after consuming one item, bar progress
										bar()

										# Variables for Command(s)
										cli_int = 'show interface eth ' + str(slot) + '/' + str(port) + ' | json'

										# Sending Command(s)
										cli_check_int = self.connection.send_command(cli_int)

										# Converting str output to dict
										cli_check_int_dict = json.loads(cli_check_int)

										# Admin Down section
										if 'down' in cli_check_int_dict["TABLE_interface"]["ROW_interface"]['admin_state']:
											ports_admin_down += 1
											continue

										# UP/Down section
										elif 'down' in cli_check_int_dict["TABLE_interface"]["ROW_interface"]['state']:
											ports_down += 1
											continue

										# Up section
										elif 'up' in cli_check_int_dict["TABLE_interface"]["ROW_interface"]['state']:

											# 100Gb section
											if '100000000' in cli_check_int_dict["TABLE_interface"]["ROW_interface"]['eth_bw']:
												ports_in_use += 1
												oper_status_100gb += 1
												sum_interfaces_100gb -= 1
												continue

											# UNKNOWN UP Section
											else:
												print("Speed don't detected, please verify !")

								# Nexus 9504 - N9K-C93180YC-EX
								elif (qtde_interfaces_100[str(slot)] == 6) and ('93180' in check_model[str(slot)]):
									# Looping trough interfaces 40GB/100GB - N9K-C93180YC-EX
									for port in range(49, 55):

										# Call after consuming one item, bar progress
										bar()

										# Variables for Command(s)
										cli_int = 'show interface eth ' + str(slot) + '/' + str(port) + ' | json'

										# Sending Command(s)
										cli_check_int = self.connection.send_command(cli_int)

										# Converting str output to dict
										cli_check_int_dict = json.loads(cli_check_int)

										# Admin Down section
										if 'down' in cli_check_int_dict["TABLE_interface"]["ROW_interface"]['admin_state']:
											ports_admin_down += 1
											continue

										# UP/Down section
										elif 'down' in cli_check_int_dict["TABLE_interface"]["ROW_interface"]['state']:
											ports_down += 1
											continue

										# Up section
										elif 'up' in cli_check_int_dict["TABLE_interface"]["ROW_interface"]['state']:

											# 100Gb section
											if '100000000' in cli_check_int_dict["TABLE_interface"]["ROW_interface"]['eth_bw']:
												ports_in_use += 1
												oper_status_100gb += 1
												sum_interfaces_100gb -= 1
												continue

											# UNKNOWN UP Section
											else:
												print("Speed don't detected on check_status_ports CISCO, please verify !")
						
						else:
							# Just inform
							print("Speed don't detected on check_status_ports, please verify !")

				# Populating return dict
				status_ports = {
					'ports_in_use': ports_in_use,
					'ports_down': ports_down,
					'ports_admin_down': ports_admin_down,
					'oper_status_1gb': oper_status_1gb,
					'oper_status_10gb': oper_status_10gb,
					'oper_status_100gb': oper_status_100gb,
					'ports_10gb_free': sum_interfaces_10gb,
					'ports_100gb_free': sum_interfaces_100gb,
				}

				return status_ports

			# HP COMWARE Section
			if self.device['device_type'] == 'hp_comware' or (self.connection.device_type == 'hp_comware'):
				
				# "Loading" message
				aux.info_message('wait')

				# Returning a list of all slots, like: [1,2,3,4] or not sequential, like: [1,2,7,8]
				qtde_slots = self.check_qtde_slots()

				# Returning a dictionary of all slots and qtde interface,
				interfaces = self.check_qtde_interfaces_slots()

				# Populating variables
				qtde_interfaces_10 = interfaces['qtde_interfaces_10']
				qtde_interfaces_100 = interfaces['qtde_interfaces_100']

				# Returning a dictionary of all Models,
				# like: {'1': 'MODEL', '2': 'MODEL', '3': 'MODEL', '4': 'MODEL'}
				# or not sequential, like: {'1': 'MODEL', '2': 'MODEL', '7': 'MODEL', '8': 'MODEL'}
				check_model = self.check_hardware_model()

				# "Done" message
				aux.info_message('collect_interface_report_done')

				# Print message to inform about collect start
				aux.info_message('start')

				# Variables for create loop commands
				# Sum of total slots
				sum_slots = 0
				for _ in qtde_slots:
					sum_slots += 1

				# Variables for create loop commands
				# 1GB/10Gb Section sum interfaces
				sum_interfaces_10gb = 0
				for ports in qtde_interfaces_10:
					sum_interfaces_10gb += int(qtde_interfaces_10[ports])

				# Variables for create loop commands
				# 100GB Section sum interfaces
				sum_interfaces_100gb = 0
				for ports in qtde_interfaces_100:
					sum_interfaces_100gb += int(qtde_interfaces_100[ports])

				# List for easy sum
				interfaces_for_sum = [
					sum_interfaces_10gb,
					sum_interfaces_100gb
				]

				# Variables for create loop commands
				# Sum of total interfaces possibilities
				sum_interfaces = 0
				for interface_count in interfaces_for_sum:
					sum_interfaces += interface_count

				# Section looping commands
				# Default setting of alive_progress as alive_bar imported for all ports
				with alive_bar(sum_interfaces, bar='smooth', spinner='waves', title=hostname_bar, length=55) as bar:

					# Lopping for maximum slots possibilities
					for slot in qtde_slots:

						# Checking if is chassis
						if '5900AF-48XG' in check_model[str(slot)]:

							# Checking if slot iterate is in interface type count dict
							if str(slot) in qtde_interfaces_10.keys():
								# Looping trough interfaces 10GB
								for port in range(1, int(qtde_interfaces_10[str(slot)] + 1)):

									# Call after consuming one item, bar progress
									bar()

									# Variables for Command(s)
									cli_int = 'display interface te ' + str(slot) + '/0/' + str(port) + ' | i state'

									# Sending Command(s)
									cli_check_int = self.connection.send_command(cli_int)

									# Admin Down section
									if 'Administratively DOWN' in cli_check_int:
										ports_admin_down += 1
										continue

									# UP/Down section
									elif 'Current state: DOWN' in cli_check_int:
										ports_down += 1
										continue

									# Up section
									elif 'Line protocol state: UP' in cli_check_int:

										# 10Gb section
										ports_in_use += 1
										oper_status_10gb += 1
										sum_interfaces_10gb -= 1
										continue					
										
									# UNKNOWN UP Section
									else:
										print("State don't detected on check_status_ports in HP Comware section, please verify !")

				# Populating return dict
				status_ports = {
					'ports_in_use': ports_in_use,
					'ports_down': ports_down,
					'ports_admin_down': ports_admin_down,
					'oper_status_1gb': oper_status_1gb,
					'oper_status_10gb': oper_status_10gb,
					'oper_status_100gb': oper_status_100gb,
					'ports_10gb_free': sum_interfaces_10gb,
					'ports_100gb_free': sum_interfaces_100gb,
				}

				return status_ports

			else:
				print("Don't find compatible device type, please verify !")
				return 'NOK'

		except Exception as e:
			print('\n{}'.format(
				str(color.prRed('*****--------------------<<<<<<<<<< BEGIN >>>>>>>>>>--------------------*****')))
			)
			print("Oops!", sys.exc_info()[0], " in ", self.device['host'].upper(), "occurred.")
			for erro in sys.exc_info():
				print(erro)
			print(
				type(e).__name__,  # Type of Error
				__file__,  # File Path
				e.__traceback__.tb_lineno  # Line Error
			)
			print('{}'.format(
				str(color.prRed('*****--------------------<<<<<<<<<< *END* >>>>>>>>>>--------------------*****\n')))
			)

			return 'NOK'

	def check_serial_number(self):
		"""
		1 - Connect in element.
		2 - Select type of element (Extreme, Brocade, HP, and so on).
		3 - Return a string with serial number, like: 'N123456', and so on ...
		+- 2s

		Parameters
		----------

		Returns
		-------
		str
		"""

		# Main Try/Except Block
		try:

			# Brocade NOS Section
			if (self.device['device_type'] == 'brocade_nos') or (self.connection.device_type == 'brocade_nos'):
				# Sending Command(s)
				cli_switch = 'show chassis | i "Factory Serial"'
				cli_check_switch = self.connection.send_command(cli_switch)

				# Variables
				serial_number = cli_check_switch.split()[-1]

				# Returning string with firmware version, like: 'N123456'
				return serial_number

			# Cisco NXOS Section
			elif (self.device['device_type'] == 'cisco_nxos') or (self.connection.device_type == 'cisco_nxos'):
				# Sending Command(s)
				cli_switch = 'show inventory'
				cli_check_switch = self.connection.send_command(cli_switch, use_textfsm=True)

				# Variables
				serial_number = cli_check_switch[0]['sn']

				# Returning string with firmware version, like: 'N123456'
				return serial_number

			# HP COMWARE Section
			if self.device['device_type'] == 'hp_comware' or (self.connection.device_type == 'hp_comware'):
				# Sending Command(s)
				cli_switch = 'display device manuinfo | i NUMBER'
				cli_check_switch = self.connection.send_command(cli_switch)

				# Variables
				serial_number = cli_check_switch.split()[2]

				# Returning string with firmware version, like: 'N123456'
				return serial_number

			else:
				return "Device Type Don't Detected !"

		except Exception as e:
			print('\n{}'.format(
				str(color.prRed('*****--------------------<<<<<<<<<< BEGIN >>>>>>>>>>--------------------*****')))
			)
			print("Oops!", sys.exc_info()[0], " in ", self.device['host'].upper(), "occurred.")
			for erro in sys.exc_info():
				print(erro)
			print(
				type(e).__name__,  # Type of Error
				__file__,  # File Path
				e.__traceback__.tb_lineno  # Line Error
			)
			print('{}'.format(
				str(color.prRed('*****--------------------<<<<<<<<<< *END* >>>>>>>>>>--------------------*****\n')))
			)

	def check_interface_traffic(self):
		"""
		1 - Connect in element.
		2 - Retrieve information.
		3 - Return a dict with interface and your traffic in and out ...
		+- 2s

		Parameters
		----------

		Returns
		-------
		dict
		"""

		# Main Try/Except Block
		try:

			# Returning a list of all slots, like: [1,2,3,4] or not sequential, like: [1,2,7,8]
			qtde_slots = self.check_qtde_slots()

			# Returning a dictionary of all Models,
			# like: {'1': 'MODEL', '2': 'MODEL', '3': 'MODEL', '4': 'MODEL'}
			# or not sequential, like: {'1': 'MODEL', '2': 'MODEL', '7': 'MODEL', '8': 'MODEL'}
			check_model = self.check_hardware_model()

			# Brocade NOS Section
			if (self.device['device_type'] == 'brocade_nos') or (self.connection.device_type == 'brocade_nos'):

				# Returning a dictionary of all slots and qtde interface,
				interfaces = self.check_qtde_interfaces_slots()

				# Populating variables
				qtde_interfaces_10 = interfaces['qtde_interfaces_10']
				qtde_interfaces_100 = interfaces['qtde_interfaces_100']
				interfaces_traffic = {}

				# Variables for create loop commands
				# 100GB Section sum interfaces
				sum_interfaces_100gb = 0
				for ports in qtde_interfaces_100:
					sum_interfaces_100gb += int(qtde_interfaces_100[ports])

				# Lopping for maximum slots possibilities
				for slot in qtde_slots:

					# Checking hardware model
					
					# Looping trough interfaces 10GB
					# Checking hardware model
					if 'BR-VDX6740' in check_model[str(slot)] or 'BR-VDX6940' in check_model[str(slot)]:

						# Looping trough interfaces 10GB
						for port in range(1, int(qtde_interfaces_10[str(slot)] + 1)):

							# Variables for Command(s)
							interface_name = 'Te' + str(slot) + '/0/' + str(port)
							cli_speed = 'show interface te ' + str(slot) + '/0/' + str(port) + ' | i line-rate'	
							cli_description = 'show interface te ' + str(slot) + '/0/' + str(port) + ' | i Description'

							# Sending Command(s)
							cli_check_speed = self.connection.send_command(cli_speed)
							cli_check_description = self.connection.send_command(cli_description)

							# Converted interfaces
							if "doesn't exist" in cli_check_speed:
								continue

							# Converted interfaces
							elif len(cli_check_speed) == 0:
								continue

							else:

								if cli_check_description[13:] != '':
									interfaces_traffic[interface_name] = \
										[str(float("{:.2f}".format(int(cli_check_speed.split()[1].split('.')[0]) / 1000))) + ' Gbps', str(float("{:.2f}".format(int(cli_check_speed.split()[9].split('.')[0]) / 1000))) + ' Gbps', cli_check_description[13:]]
								else:
									interfaces_traffic[interface_name] = \
										[str(float("{:.2f}".format(int(cli_check_speed.split()[1].split('.')[0]) / 1000))) + ' Gbps', str(float("{:.2f}".format(int(cli_check_speed.split()[9].split('.')[0]) / 1000))) + ' Gbps', 'N/A']						

						# Checking if slot iterate is in interface type count dict
						if (str(slot) in qtde_interfaces_100.keys()) and (sum_interfaces_100gb > 0):

							# Looping trough interfaces 100GB
							# 100GB Section Group 1
							for port in range(97, 99):

								# Variables for Command(s)
								interface_name = 'Hu' + str(slot) + '/0/' + str(port)
								cli_speed = 'show interface hu ' + str(slot) + '/0/' + str(port) + ' | i line-rate'	
								cli_description = 'show interface hu ' + str(slot) + '/0/' + str(port) + ' | i Description'

								# Sending Command(s)
								cli_check_speed = self.connection.send_command(cli_speed)
								cli_check_description = self.connection.send_command(cli_description)

								# Converted interfaces
								if "doesn't exist" in cli_check_speed:
									continue

								# Converted interfaces
								elif len(cli_check_speed) == 0:
									continue
								
								else:

									if cli_check_description[13:] != '':
										interfaces_traffic[interface_name] = \
											[str(float("{:.2f}".format(int(cli_check_speed.split()[1].split('.')[0]) / 1000))) + ' Gbps', str(int(cli_check_speed.split()[9].split('.')[0]) / 1000) + ' Gbps', cli_check_description[13:]]
									else:
										interfaces_traffic[interface_name] = \
											[str(float("{:.2f}".format(int(cli_check_speed.split()[1].split('.')[0]) / 1000))) + ' Gbps', str(int(cli_check_speed.split()[9].split('.')[0]) / 1000) + ' Gbps', 'N/A']			

							# 100GB Section Group 2
							for port in range(103, 105):

								# Variables for Command(s)
								interface_name = 'Hu' + str(slot) + '/0/' + str(port)
								cli_speed = 'show interface hu ' + str(slot) + '/0/' + str(port) + ' | i line-rate'	
								cli_description = 'show interface hu ' + str(slot) + '/0/' + str(port) + ' | i Description'

								# Sending Command(s)
								cli_check_speed = self.connection.send_command(cli_speed)
								cli_check_description = self.connection.send_command(cli_description)

								# Converted interfaces
								if "doesn't exist" in cli_check_speed:
									continue

								# Converted interfaces
								elif len(cli_check_speed) == 0:
									continue

								else:

									if cli_check_description[13:] != '':
										interfaces_traffic[interface_name] = \
											[str(float("{:.2f}".format(int(cli_check_speed.split()[1].split('.')[0]) / 1000))) + ' Gbps', str(float("{:.2f}".format(int(cli_check_speed.split()[9].split('.')[0]) / 1000))) + ' Gbps', cli_check_description[13:]]
									else:
										interfaces_traffic[interface_name] = \
											[str(float("{:.2f}".format(int(cli_check_speed.split()[1].split('.')[0]) / 1000))) + ' Gbps', str(float("{:.2f}".format(int(cli_check_speed.split()[9].split('.')[0]) / 1000))) + ' Gbps', 'N/A']		
									
				return interfaces_traffic

			# Cisco NXOS Section
			elif (self.device['device_type'] == 'cisco_nxos') or (self.connection.device_type == 'cisco_nxos'):

				if ('9504' in check_model['1']) or ('93180' in check_model['1']):

					# Sending Command(s)
					cli_interface = 'show interface | json'
					cli_check_interface = self.connection.send_command(cli_interface)

					# Converting str output to dict
					cli_check_switch_dict = json.loads(cli_check_interface)

					# Variables
					interfaces_traffic = {}

					for interface in cli_check_switch_dict['TABLE_interface']['ROW_interface']:	
						if 'Ethernet' in interface['interface'] or 'port-channel' in interface['interface']:
							if 'desc' in interface.keys():
								interfaces_traffic[interface['interface']] = \
									[interface['eth_inrate1_summary_bits'], interface['eth_outrate1_summary_bits'], interface['desc']]
							else:
								interfaces_traffic[interface['interface']] = \
									[interface['eth_inrate1_summary_bits'], interface['eth_outrate1_summary_bits'], 'N/A']
						
				# Returning string with firmware version, like: 'N123456'
				return interfaces_traffic

			# HP COMWARE Section
			if self.device['device_type'] == 'hp_comware' or (self.connection.device_type == 'hp_comware'):

				# Returning a dictionary of all slots and qtde interface,
				interfaces = self.check_qtde_interfaces_slots()

				# Populating variables
				qtde_interfaces_10 = interfaces['qtde_interfaces_10']
				qtde_interfaces_100 = interfaces['qtde_interfaces_100']
				interfaces_traffic = {}

				# Lopping for maximum slots possibilities
				for slot in qtde_slots:

					# Checking hardware model
					
					# Looping trough interfaces 10GB
					# Checking hardware model
					if '5900AF-48XG' in check_model[str(slot)] :

						# Looping trough interfaces 10GB
						for port in range(1, int(qtde_interfaces_10[str(slot)] + 1)):

							# Variables for Command(s)
							interface_name = 'Ten-Gig' + str(slot) + '/0/' + str(port)
							cli_speed = 'display interface te ' + str(slot) + '/0/' + str(port) + ' | i Last'								
							cli_description = 'display interface te ' + str(slot) + '/0/' + str(port) + ' | i Description'

							# Sending Command(s)
							cli_check_speed = self.connection.send_command(cli_speed)
							cli_check_description = self.connection.send_command(cli_description)

							# Converted interfaces
							if "doesn't exist" in cli_check_speed:
								continue

							# Converted interfaces
							elif len(cli_check_speed) == 0:
								continue

							else:			
								if cli_check_description.split(':')[1] != '':
									if (cli_check_speed.split()[13].split('%')[0] == '-') and (cli_check_speed.split()[-1].split('%')[0] == '-'):
										interfaces_traffic[interface_name] = ['0 Gbps', '0 Gbps', cli_check_description[13:]]
									else:
										interfaces_traffic[interface_name] = \
											[str(float("{:.2f}".format((((int(cli_check_speed.split()[13].split('%')[0]) * 10000) / 100) /1000)))) + ' Gbps', str(float("{:.2f}".format((((int(cli_check_speed.split()[-1].split('%')[0]) * 10000) / 100) /1000)))) + ' Gbps', cli_check_description[13:]]
								else:
									if (cli_check_speed.split()[13].split('%')[0] == '-') and (cli_check_speed.split()[-1].split('%')[0] == '-'):
										interfaces_traffic[interface_name] = ['0 Gbps', '0 Gbps', 'N/A']	
									else:										
										interfaces_traffic[interface_name] = \
												[str(float("{:.2f}".format((((int(cli_check_speed.split()[13].split('%')[0]) * 10000) / 100) /1000)))) + ' Gbps', str(float("{:.2f}".format((((int(cli_check_speed.split()[-1].split('%')[0]) * 10000) / 100) /1000)))) + ' Gbps', 'N/A']						

				return interfaces_traffic

			else:
				return "Device Type Don't Detected on check_interface_traffic Method!"

		except Exception as e:
			print('\n{}'.format(
				str(color.prRed('*****--------------------<<<<<<<<<< BEGIN >>>>>>>>>>--------------------*****')))
			)
			print("Oops!", sys.exc_info()[0], " in ", self.device['host'].upper(), "occurred.")
			for erro in sys.exc_info():
				print(erro)
			print(
				type(e).__name__,  # Type of Error
				__file__,  # File Path
				e.__traceback__.tb_lineno  # Line Error
			)
			print('{}'.format(
				str(color.prRed('*****--------------------<<<<<<<<<< *END* >>>>>>>>>>--------------------*****\n')))
			)

	def interface_report(self, output_log='', dir_report='', automation=False):
		"""
		1 - Connect in element.
		2 - Select type of element (Extreme, Brocade, HP, and so on).
		3 - Create .csv file with interface information ...

		Parameters
		----------
			output_log: io.TextIOWrapper
				Archive for store report in case of automation
			dir_report: str
				Only used if automation is True
			automation: boolean
				For identify main function of execution, only one report (=False) or N reports (=True)

		Returns
		-------
		str
		"""

		# Main Try/Except Block
		try:

			# Variable for show hostname in alive bar
			hostname_bar = self.connection.find_prompt()[0:len(self.connection.find_prompt())-1]

			# Instance of Auxiliary class
			aux = Auxiliary(self.device, self.connection)

			if not automation:
				# Making Report Directory
				dir_report = aux.make_report_directory()

			if not automation:
				# Creating .csv log file
				output_log = aux.make_output_log_file('open')[0]

			# Extreme EXOS Section
			if self.device['device_type'] == 'extreme_telnet':

				# "Loading" message
				aux.info_message('wait')

				# Returning a list of all slots, like: [1,2,3,4] or not sequential, like: [1,2,7,8]
				qtde_slots = self.check_qtde_slots()

				# Returning a dictionary of all slots and qtde interface,
				# like: {'1': 26, '2': 26, '3': 48, '4': 48}
				# or not sequential, like: {'1': 26, '2': 26, '7': 48, '8': 48}
				qtde_interfaces = self.check_qtde_interfaces_slots()

				# Returning a dictionary of all Models,
				# like: {'1': 'MODEL', '2': 'MODEL', '3': 'MODEL', '4': 'MODEL'}
				# or not sequential, like: {'1': 'MODEL', '2': 'MODEL', '7': 'MODEL', '8': 'MODEL'}
				check_model = self.check_hardware_model()

				# "Done" message
				aux.info_message('collect_interface_report_done')

				# Variables for create loop commands
				sum_slots = 0
				sum_interfaces = 0

				# Print message to inform about collect start
				aux.info_message('start')

				for _ in qtde_slots:
					sum_slots += 1

				for ports in qtde_interfaces:
					sum_interfaces += int(qtde_interfaces[ports])

				# Default setting of alive_progress as alive_bar imported
				with alive_bar(sum_interfaces, bar='smooth', spinner='waves', title=hostname_bar, length=55) as bar:

					# Looping trough interfaces
					for slot in qtde_slots:
						for port in range(1, int(qtde_interfaces[str(slot)]) + 1):

							# Variables for Command(s)
							cli_state = 'show ports ' + str(slot) + ':' + str(port) + ' info detail | i "Link State"'
							cli_media_type = 'show ports ' + str(slot) + ':' + str(port) + ' info detail | i Type:'
							cli_description = 'show ports ' + str(slot) + ':' + str(port) + ' info detail | i Port:'

							# Sending Command(s)
							cli_check_state = self.connection.send_command(cli_state)
							cli_check_media_type = self.connection.send_command(cli_media_type)
							cli_check_description = self.connection.send_command(cli_description)

							# Adjusting Media Type With Redundant Type
							pos = cli_check_media_type.find("\n")
							media_type = cli_check_media_type[:pos]

							# Populating Report, skipping invalid or DOWN interfaces
							if('Invalid' in cli_check_state) and ('detected' in cli_check_state):
								bar()
								continue
							elif 'Active' not in cli_check_state:
								output_log.write(
									check_model[str(slot)] +
									';' +
									self.device['host'].upper() +
									';' +
									str(slot) +
									':' +
									str(port) +
									';' +
									'DOWN' +
									';' +
									media_type[8:] +
									';' +
									'N/A' +
									';' +
									cli_check_description[6:] +
									'\n'
								)
								bar()
								continue

							# Populating Report = HOSTNAME;HARDWARE MODEL;IF STATUS;IF;MEDIA;SPEED;DESCRIPTION
							elif 'Active' in cli_check_state:
								if '1Gbps' in cli_check_state:
									output_log.write(
										check_model[str(slot)] +
										';' +
										self.device['host'].upper() +
										';' +
										str(slot) +
										':' +
										str(port) +
										';' +
										'UP' +
										';' +
										media_type[8:] +
										';' +
										'1Gbps' +
										';' +
										cli_check_description[6:] +
										'\n'
									)
								elif '10Gbps' in cli_check_state:
									output_log.write(
										check_model[str(slot)] +
										';' +
										self.device['host'].upper() +
										';' +
										str(slot) +
										':' +
										str(port) +
										';' +
										'UP' +
										';' +
										media_type[8:] +
										';' +
										'10Gbps' +
										';' +
										cli_check_description[6:] +
										'\n'
									)
								else:
									output_log.write(
										check_model[str(slot)] +
										';' +
										self.device['host'].upper() +
										';' +
										str(slot) +
										':' +
										str(port) +
										';' +
										'UP' +
										';' +
										media_type[8:] +
										';' +
										'100Mbps' +
										';' +
										cli_check_description[6:] +
										'\n'
									)

							# UNKNOWN Section
							else:
								print(
									self.device['host'].upper() +
									' Port ' +
									str(slot) +
									':' +
									str(port) +
									':{}'.format(str(color.prRed(' is Down or Media Type Not Detected!'))))
								output_log.write(
									check_model[str(slot)] +
									';' +
									self.device['host'].upper() +
									';' +
									check_model[str(slot)] +
									';' +
									'DOWN or ND' +
									';' +
									str(slot) +
									':' +
									str(port) +
									';' +
									media_type[8:] +
									';' +
									'N/A' +
									';' +
									cli_check_description[6:] +
									'\n'
								)

							# Call after consuming one item, bar progress
							bar()

				# Closing Log File
				if not automation:
					aux.make_output_log_file('close', output_log)

				# Closing connection
				# self.connection.disconnect()

				return 'OK'

			# Brocade NOS Section
			elif (self.device['device_type'] == 'brocade_nos') or (self.connection.device_type == 'brocade_nos'):

				# "Loading" message
				aux.info_message('wait')

				# Returning a list of all slots, like: [1,2,3,4] or not sequential, like: [1,2,7,8]
				qtde_slots = self.check_qtde_slots()

				# Returning a dictionary of all slots and qtde interface,
				# like: {'1': 26, '2': 26, '3': 48, '4': 48}
				# or not sequential, like: {'1': 26, '2': 26, '7': 48, '8': 48}
				qtde_interfaces_1_10, qtde_interfaces_40, qtde_interfaces_100 = self.check_qtde_interfaces_slots()

				# Returning a dictionary of all Models,
				# like: {'1': 'MODEL', '2': 'MODEL', '3': 'MODEL', '4': 'MODEL'}
				# or not sequential, like: {'1': 'MODEL', '2': 'MODEL', '7': 'MODEL', '8': 'MODEL'}
				check_model = self.check_hardware_model()

				# "Done" message
				aux.info_message('collect_interface_report_done')

				# Print message to inform about collect start
				aux.info_message('start')

				# Variables for create loop commands
				# Sum of total slots
				sum_slots = 0
				for _ in qtde_slots:
					sum_slots += 1

				# Variables for create loop commands
				# 1GB/10GB Section sum interface
				sum_interfaces_10gb = 0
				for ports in qtde_interfaces_1_10:
					sum_interfaces_10gb += int(qtde_interfaces_1_10[ports])

				# Variables for create loop commands
				# 40GB Section sum interfaces
				sum_interfaces_40gb = 0
				for ports in qtde_interfaces_40:
					sum_interfaces_40gb += int(qtde_interfaces_40[ports])

				# Variables for create loop commands
				# 100GB Section sum interfaces
				sum_interfaces_100gb = 0
				for ports in qtde_interfaces_100:
					sum_interfaces_100gb += int(qtde_interfaces_100[ports])

				# Variables for create loop commands
				# Sum of total interfaces possibilities
				sum_interfaces = sum_interfaces_10gb + sum_interfaces_40gb + sum_interfaces_100gb

				# Section looping commands
				# Default setting of alive_progress as alive_bar imported for all ports
				with alive_bar(sum_interfaces, bar='smooth', spinner='waves', title=hostname_bar, length=55) as bar:

					for slot in qtde_slots:

						# Checking hardware model for breakout interfaces
						if 'VDX6740T-1G' in check_model[str(slot)]:

							# Looping trough interfaces 10GB
							for port in range(1, int(qtde_interfaces_1_10[str(slot)] + 1)):

								# Call after consuming one item, bar progress
								bar()

								# Variables for Command(s)
								cli_state = 'show interface te ' + str(slot) + '/0/' + str(port) + ' | i protocol'
								cli_speed = 'show interface te ' + str(slot) + '/0/' + str(port) + ' | i "LineSpeed Actual"'
								cli_description = 'show interface te ' + str(slot) + '/0/' + str(port) + ' | i Description'

								# Sending Command(s)
								cli_check_state = self.connection.send_command(cli_state)
								cli_check_speed = self.connection.send_command(cli_speed)
								cli_check_description = self.connection.send_command(cli_description)

								# Populating Report, skipping invalid or DOWN interfaces
								if 'admin down' in cli_check_state:
									output_log.write(
										check_model[str(slot)] +
										';' +
										self.device['host'].upper() +
										';' +
										'Te' +
										str(slot) +
										'/0/' +
										str(port) +
										';' +
										'DOWN(ADMIN)' +
										';' +
										'UTP' +
										';' +
										'N/A' +
										';' +
										cli_check_description[13:] +
										'\n'
									)
									continue
								elif 'protocol is up (connected)' not in cli_check_state:
									output_log.write(
										check_model[str(slot)] +
										';' +
										self.device['host'].upper() +
										';' +
										'Te' +
										str(slot) +
										'/0/' +
										str(port) +
										';' +
										'DOWN' +
										';' +
										'UTP' +
										';' +
										'N/A' +
										';' +
										cli_check_description[13:] +
										'\n'
									)
									continue

								# Populating Report 10GB = HOSTNAME;HARDWARE MODEL;IF STATUS;IF;MEDIA;SPEED;DESCRIPTION
								elif 'protocol is up (connected)' in cli_check_state:
									if '100 Mbit' in cli_check_speed:
										output_log.write(
											check_model[str(slot)] +
											';' +
											self.device['host'].upper() +
											';' +
											'Te' +
											str(slot) +
											'/0/' +
											str(port) +
											';' +
											'UP' +
											';' +
											'UTP' +
											';' +
											'100Mbps' +
											';' +
											cli_check_description[13:] +
											'\n'
										)
									elif '1000 Mbit' in cli_check_speed:
										output_log.write(
											check_model[str(slot)] +
											';' +
											self.device['host'].upper() +
											';' +
											'Te' +
											str(slot) +
											'/0/' +
											str(port) +
											';' +
											'UP' +
											';' +
											'UTP' +
											';' +
											'1Gbps' +
											';' +
											cli_check_description[13:] +
											'\n'
										)
									elif '10000 Mbit' in cli_check_speed:
										output_log.write(
											check_model[str(slot)] +
											';' +
											self.device['host'].upper() +
											';' +
											'Te' +
											str(slot) +
											'/0/' +
											str(port) +
											';' +
											'UP' +
											';' +
											'UTP' +
											';' +
											'10Gbps' +
											';' +
											cli_check_description[13:] +
											'\n'
										)
									else:
										output_log.write(
											check_model[str(slot)] +
											';' +
											self.device['host'].upper() +
											';' +
											'Te' +
											str(slot) +
											'/0/' +
											str(port) +
											';' +
											'UP' +
											';' +
											'UTP' +
											';' +
											'ND' +
											';' +
											cli_check_description[13:] +
											'\n'
										)

								# UNKNOWN Section
								else:
									print(
										self.device['host'].upper() +
										' Port ' +
										str(slot) +
										'/0/' +
										str(port) +
										':{}'.format(str(color.prRed(' is Down or Media Type Not Detected!'))))
									output_log.write(
										check_model[str(slot)] +
										';' +
										self.device['host'].upper() +
										';' +
										';' +
										'Te' +
										str(slot) +
										'/0/' +
										str(port) +
										'DOWN or ND' +
										';' +
										'UTP' +
										';' +
										'N/A' +
										';' +
										cli_check_description[13:] +
										'\n'
									)

							# Looping trough interfaces 40GB
							# 40GB Normal and Breakout interfaces
							# 40GB Normal interfaces
							for port in range(49, 53):

								# Call after consuming one item, bar progress
								bar()

								# Variables for Command(s)
								cli_state = 'show interface fo ' + str(slot) + '/0/' + str(port) + ' | i protocol'
								cli_media_type = 'show media interface fo ' + str(slot) + '/0/' + str(port) + ' | i Name | exclude Vendor'
								cli_media_transceiver = 'show media interface fo ' + str(slot) + '/0/' + str(port) + ' | i Transceiver'
								cli_description = 'show interface fo ' + str(slot) + '/0/' + str(port) + ' | i Description'

								# Sending Command(s)
								cli_check_state = self.connection.send_command(cli_state)
								cli_check_media_type = self.connection.send_command(cli_media_type)
								cli_check_transceiver = self.connection.send_command(cli_media_transceiver)
								cli_check_description = self.connection.send_command(cli_description)

								# For populating report about sfp type, 40GB
								# Multimode
								if 'id' in cli_check_media_type[17:]:
									if '40_GB/s  Short_dist' in cli_check_transceiver:
										sfp_type = '40G-QSFP - DIRECT ATTACH'
									else:
										sfp_type = 'MM 40GB - NOT DETECTED'
								# EMPTY
								elif '' in cli_check_media_type:
									sfp_type = 'EMPTY'
								# UNKNOWN
								else:
									sfp_type = 'NOT DETECTED'

								# Populating Report, skipping invalid or DOWN interfaces
								if "doesn't exist" in cli_check_state:
									output_log.write(
										check_model[str(slot)] +
										';' +
										self.device['host'].upper() +
										';' +
										'Fo' +
										str(slot) +
										'/0/' +
										str(port) +
										';' +
										'ND' +
										';' +
										'ND' +
										';' +
										'ND' +
										';' +
										'ND' +
										'\n'
									)
									# continue - not necessary here, because is certain shutdown or doesn't exist for breakout
								elif 'admin down' in cli_check_state:
									output_log.write(
										check_model[str(slot)] +
										';' +
										self.device['host'].upper() +
										';' +
										'Fo' +
										str(slot) +
										'/0/' +
										str(port) +
										';' +
										'DOWN(ADMIN)' +
										';' +
										sfp_type +
										';' +
										'40Gbps' +
										';' +
										cli_check_description[13:] +
										'\n'
									)

								elif 'protocol is up (connected)' not in cli_check_state:
									output_log.write(
										check_model[str(slot)] +
										';' +
										self.device['host'].upper() +
										';' +
										'Fo' +
										str(slot) +
										'/0/' +
										str(port) +
										';' +
										'DOWN' +
										';' +
										sfp_type +
										';' +
										'40Gbps' +
										';' +
										cli_check_description[13:] +
										'\n'
									)

								# Populating Report = HOSTNAME;HARDWARE MODEL;IF STATUS;IF;MEDIA;SPEED;DESCRIPTION
								elif'protocol is up (connected)' in cli_check_state:
									output_log.write(
										check_model[str(slot)] +
										';' +
										self.device['host'].upper() +
										';' +
										'Fo' +
										str(slot) +
										'/0/' +
										str(port) +
										';' +
										'UP' +
										';' +
										sfp_type +
										';' +
										'40Gbps' +
										';' +
										cli_check_description[13:] +
										'\n'
									)

								# UNKNOWN Section
								else:
									print(
										self.device['host'].upper() +
										' Port ' +
										str(slot) +
										'/0/' +
										str(port) +
										':{}'.format(str(color.prRed(' is Down or Media Type Not Detected!'))))
									output_log.write(
										check_model[str(slot)] +
										';' +
										self.device['host'].upper() +
										';' +
										';' +
										'Fo' +
										str(slot) +
										'/0/' +
										str(port) +
										'DOWN or ND' +
										';' +
										sfp_type +
										';' +
										'N/A' +
										';' +
										cli_check_description[13:] +
										'\n'
									)

								# 40GB Breakout interfaces
								for breakout in range(1, 5):

									# Call after consuming one item, bar progress
									bar()

									# Variables for Command(s)
									cli_state = 'show interface te {}/0/{}:{} | i protocol'.format(
										str(slot),
										str(port),
										str(breakout)
									)
									cli_media_type = 'show media interface te {}/0/{}:{} | i Name | exclude Vendor'.format(
										str(slot),
										str(port),
										str(breakout)
									)
									cli_media_transceiver = 'show media interface te {}/0/{}:{} | i Transceiver'.format(
										str(slot),
										str(port),
										str(breakout)
									)
									cli_description = 'show interface te {}/0/{}:{} | i Description'.format(
										str(slot),
										str(port),
										str(breakout)
									)

									# Sending Command(s)
									cli_check_state = self.connection.send_command(cli_state)
									cli_check_media_type = self.connection.send_command(cli_media_type)
									cli_check_transceiver = self.connection.send_command(cli_media_transceiver)
									cli_check_description = self.connection.send_command(cli_description)

									# For populating report about sfp type, 40GB
									# Multimode
									if 'id' in cli_check_media_type[17:]:
										if '40_GB/s  Short_dist' in cli_check_transceiver:
											sfp_type = '40G-QSFP - 4x10GB BREAKOUT'
										else:
											sfp_type = 'MM 40GB BREAKOUT- NOT DETECTED'
									# EMPTY
									elif '' in cli_check_media_type:
										sfp_type = 'EMPTY'
									# UNKNOWN
									else:
										sfp_type = 'NOT DETECTED'

									# Populating Report, skipping invalid or DOWN interfaces
									if "doesn't exist" in cli_check_state:
										output_log.write(
											check_model[str(slot)] +
											';' +
											self.device['host'].upper() +
											';' +
											'Te' +
											str(slot) +
											'/0/' +
											str(port) +
											':' +
											str(breakout) +
											';' +
											'ND' +
											';' +
											'ND' +
											';' +
											'ND' +
											';' +
											'ND' +
											'\n'
										)
										continue
									elif 'admin down' in cli_check_state:
										output_log.write(
											check_model[str(slot)] +
											';' +
											self.device['host'].upper() +
											';' +
											'Te' +
											str(slot) +
											'/0/' +
											str(port) +
											':' +
											str(breakout) +
											';' +
											'DOWN(ADMIN)' +
											';' +
											sfp_type +
											';' +
											'10Gbps' +
											';' +
											cli_check_description[13:] +
											'\n'
										)
										continue
									elif 'protocol is up (connected)' not in cli_check_state:
										output_log.write(
											check_model[str(slot)] +
											';' +
											self.device['host'].upper() +
											';' +
											'Te' +
											str(slot) +
											'/0/' +
											str(port) +
											':' +
											str(breakout) +
											';' +
											'DOWN' +
											';' +
											sfp_type +
											';' +
											'10Gbps' +
											';' +
											cli_check_description[13:] +
											'\n'
										)
										continue

									# Populating Report = HOSTNAME;HARDWARE MODEL;IF STATUS;IF;MEDIA;SPEED;DESCRIPTION
									elif 'protocol is up (connected)' in cli_check_state:
										output_log.write(
											check_model[str(slot)] +
											';' +
											self.device['host'].upper() +
											';' +
											'Te' +
											str(slot) +
											'/0/' +
											str(port) +
											':' +
											str(breakout) +
											';' +
											'UP' +
											';' +
											sfp_type +
											';' +
											'10Gbps' +
											';' +
											cli_check_description[13:] +
											'\n'
										)

									# UNKNOWN Section
									else:
										print(
											self.device['host'].upper() +
											' Port ' +
											str(slot) +
											'/0/' +
											str(port) +
											':{}'.
											format(str(color.prRed(' is Down or Media Type Not Detected!'))))
										output_log.write(
											check_model[str(slot)] +
											';' +
											self.device['host'].upper() +
											';' +
											';' +
											'Te' +
											str(slot) +
											'/0/' +
											str(port) +
											':' +
											str(breakout) +
											'DOWN or ND' +
											';' +
											sfp_type +
											';' +
											'N/A' +
											';' +
											cli_check_description[13:] +
											'\n'
										)

						# Looping trough interfaces 40GB
						# Checking hardware model for breakout interfaces
						elif 'BR-VDX6740' in check_model[str(slot)]:

							# Looping trough interfaces 10GB
							for port in range(1, int(qtde_interfaces_1_10[str(slot)] + 1)):

								# Call after consuming one item, bar progress
								bar()

								# Variables for Command(s)
								cli_state = 'show interface te ' + str(slot) + '/0/' + str(port) + ' | i protocol'
								cli_speed = 'show interface te ' + str(slot) + '/0/' + str(port) + ' | i "LineSpeed Actual"'
								cli_media_type = 'show media interface te ' + str(slot) + '/0/' + str(port) + ' | i Name | exclude Vendor'
								cli_media_transceiver = 'show media interface te ' + str(slot) + '/0/' + str(port) + ' | i Transceiver'
								cli_media_connector = 'show media interface te ' + str(slot) + '/0/' + str(port) + ' | i Connector'
								cli_description = 'show interface te ' + str(slot) + '/0/' + str(port) + ' | i Description'

								# Sending Command(s)
								cli_check_state = self.connection.send_command(cli_state)
								cli_check_speed = self.connection.send_command(cli_speed)
								cli_check_media_type = self.connection.send_command(cli_media_type)
								cli_check_transceiver = self.connection.send_command(cli_media_transceiver)
								cli_check_connector = self.connection.send_command(cli_media_connector)
								cli_check_description = self.connection.send_command(cli_description)

								# For populating report about sfp type, LX, SX, UTP, LR, SR
								# Multimode
								if 'sw' in cli_check_media_type[17:]:
									if '10_GB' in cli_check_transceiver:
										sfp_type = '10G-SFP-SR'
									elif '1_GB' in cli_check_transceiver:
										sfp_type = '1G-SFP-SX'
									else:
										sfp_type = 'MM - NOT DETECTED'
								# Monomode
								elif 'lw' in cli_check_media_type[17:]:
									if '10_GB' in cli_check_transceiver:
										sfp_type = '10G-SFP-LR'
									elif '1_GB' in cli_check_transceiver:
										sfp_type = '1G-SFP-LX'
									else:
										sfp_type = 'SM - NOT DETECTED'
								# Base T or Direct Attach
								elif 'cu' in cli_check_media_type[17:]:
									if port <= 44:
										sfp_type = 'UTP'
									else:
										sfp_type = 'DIRECT ATTACH'
								# Direct Attach
								elif 'id' in cli_check_media_type[17:]:
									if 'Copper Pigtail' in cli_check_connector:
										sfp_type = 'DIRECT ATTACH'
									else:
										sfp_type = 'ID NOT DETECTED'
								# EMPTY
								elif '' in cli_check_media_type:
									sfp_type = 'EMPTY'
								# UNKNOWN
								else:
									sfp_type = 'NOT DETECTED'

								# Populating Report, skipping invalid or DOWN interfaces
								if 'admin down' in cli_check_state:
									output_log.write(
										check_model[str(slot)] +
										';' +
										self.device['host'].upper() +
										';' +
										'Te' +
										str(slot) +
										'/0/' +
										str(port) +
										';' +
										'DOWN(ADMIN)' +
										';' +
										sfp_type +
										';' +
										'N/A' +
										';' +
										cli_check_description[13:] +
										'\n'
									)
									continue
								elif 'protocol is up (connected)' not in cli_check_state:
									output_log.write(
										check_model[str(slot)] +
										';' +
										self.device['host'].upper() +
										';' +
										'Te' +
										str(slot) +
										'/0/' +
										str(port) +
										';' +
										'DOWN' +
										';' +
										sfp_type +
										';' +
										'N/A' +
										';' +
										cli_check_description[13:] +
										'\n'
									)
									continue

								# Populating Report 10GB = HOSTNAME;HARDWARE MODEL;IF STATUS;IF;MEDIA;SPEED;DESCRIPTION
								elif 'protocol is up (connected)' in cli_check_state:
									if '100 Mbit' in cli_check_speed:
										output_log.write(
											check_model[str(slot)] +
											';' +
											self.device['host'].upper() +
											';' +
											'Te' +
											str(slot) +
											'/0/' +
											str(port) +
											';' +
											'UP' +
											';' +
											sfp_type +
											';' +
											'100Mbps' +
											';' +
											cli_check_description[13:] +
											'\n'
										)
									elif '1000 Mbit' in cli_check_speed:
										output_log.write(
											check_model[str(slot)] +
											';' +
											self.device['host'].upper() +
											';' +
											'Te' +
											str(slot) +
											'/0/' +
											str(port) +
											';' +
											'UP' +
											';' +
											sfp_type +
											';' +
											'1Gbps' +
											';' +
											cli_check_description[13:] +
											'\n'
										)
									elif '10000 Mbit' in cli_check_speed:
										output_log.write(
											check_model[str(slot)] +
											';' +
											self.device['host'].upper() +
											';' +
											'Te' +
											str(slot) +
											'/0/' +
											str(port) +
											';' +
											'UP' +
											';' +
											sfp_type +
											';' +
											'10Gbps' +
											';' +
											cli_check_description[13:] +
											'\n'
										)
									else:
										output_log.write(
											check_model[str(slot)] +
											';' +
											self.device['host'].upper() +
											';' +
											'Te' +
											str(slot) +
											'/0/' +
											str(port) +
											';' +
											'UP' +
											';' +
											sfp_type +
											';' +
											'ND' +
											';' +
											cli_check_description[13:] +
											'\n'
										)

								# UNKNOWN Section
								else:
									print(
										self.device['host'].upper() +
										' Port ' +
										str(slot) +
										'/0/' +
										str(port) +
										':{}'.format(str(color.prRed(' is Down or Media Type Not Detected!')))
									)
									output_log.write(
										check_model[str(slot)] +
										';' +
										self.device['host'].upper() +
										';' +
										';' +
										'Te' +
										str(slot) +
										'/0/' +
										str(port) +
										'DOWN or ND' +
										';' +
										sfp_type +
										';' +
										'N/A' +
										';' +
										cli_check_description[13:] +
										'\n'
									)

							# 40GB Normal and Breakout interfaces
							# 40GB Normal interfaces
							for port in range(49, 53):

								# Call after consuming one item, bar progress
								bar()

								# Variables for Command(s)
								cli_state = 'show interface fo ' + str(slot) + '/0/' + str(port) + ' | i protocol'
								cli_media_type = 'show media interface fo ' + str(slot) + '/0/' + str(port) + ' | i Name | exclude Vendor'
								cli_media_transceiver = 'show media interface fo ' + str(slot) + '/0/' + str(port) + ' | i Transceiver'
								cli_description = 'show interface fo ' + str(slot) + '/0/' + str(port) + ' | i Description'

								# Sending Command(s)
								cli_check_state = self.connection.send_command(cli_state)
								cli_check_media_type = self.connection.send_command(cli_media_type)
								cli_check_transceiver = self.connection.send_command(cli_media_transceiver)
								cli_check_description = self.connection.send_command(cli_description)

								# For populating report about sfp type, 40GB
								# Multimode
								if 'id' in cli_check_media_type[17:]:
									if '40_GB/s  Short_dist' in cli_check_transceiver:
										sfp_type = '40G-QSFP - DIRECT ATTACH'
									else:
										sfp_type = 'MM 40GB - NOT DETECTED'
								# EMPTY
								elif '' in cli_check_media_type:
									sfp_type = 'EMPTY'
								# UNKNOWN
								else:
									sfp_type = 'NOT DETECTED'

								# Populating Report, skipping invalid or DOWN interfaces
								if "doesn't exist" in cli_check_state:
									output_log.write(
										check_model[str(slot)] +
										';' +
										self.device['host'].upper() +
										';' +
										'Fo' +
										str(slot) +
										'/0/' +
										str(port) +
										';' +
										'ND' +
										';' +
										'ND' +
										';' +
										'ND' +
										';' +
										'ND' +
										'\n'
									)
									continue
								elif 'admin down' in cli_check_state:
									output_log.write(
										check_model[str(slot)] +
										';' +
										self.device['host'].upper() +
										';' +
										'Fo' +
										str(slot) +
										'/0/' +
										str(port) +
										';' +
										'DOWN(ADMIN)' +
										';' +
										sfp_type +
										';' +
										'40Gbps' +
										';' +
										cli_check_description[13:] +
										'\n'
									)
									continue
								elif 'protocol is up (connected)' not in cli_check_state:
									output_log.write(
										check_model[str(slot)] +
										';' +
										self.device['host'].upper() +
										';' +
										'Fo' +
										str(slot) +
										'/0/' +
										str(port) +
										';' +
										'DOWN' +
										';' +
										sfp_type +
										';' +
										'40Gbps' +
										';' +
										cli_check_description[13:] +
										'\n'
									)
									continue

								# Populating Report = HOSTNAME;HARDWARE MODEL;IF STATUS;IF;MEDIA;SPEED;DESCRIPTION
								elif 'protocol is up (connected)' in cli_check_state:
									output_log.write(
										check_model[str(slot)] +
										';' +
										self.device['host'].upper() +
										';' +
										'Fo' +
										str(slot) +
										'/0/' +
										str(port) +
										';' +
										'UP' +
										';' +
										sfp_type +
										';' +
										'40Gbps' +
										';' +
										cli_check_description[13:] +
										'\n'
									)

								# UNKNOWN Section
								else:
									print(
										self.device['host'].upper() +
										' Port ' +
										str(slot) +
										'/0/' +
										str(port) +
										':{}'.format(str(color.prRed(' is Down or Media Type Not Detected!'))))
									output_log.write(
										check_model[str(slot)] +
										';' +
										self.device['host'].upper() +
										';' +
										';' +
										'Fo' +
										str(slot) +
										'/0/' +
										str(port) +
										'DOWN or ND' +
										';' +
										sfp_type +
										';' +
										'N/A' +
										';' +
										cli_check_description[13:] +
										'\n'
									)

						# Looping trough interfaces 40GB and 100GB # VDX6940
						# Checking hardware model for breakout interfaces
						else:  # VDX6940

							# Looping trough interfaces 10GB
							for port in range(1, int(qtde_interfaces_1_10[str(slot)] + 1)):

								# Call after consuming one item, bar progress
								bar()

								# Variables for Command(s)
								cli_state = 'show interface te ' + str(slot) + '/0/' + str(port) + ' | i protocol'
								cli_speed = 'show interface te ' + str(slot) + '/0/' + str(port) + ' | i "LineSpeed Actual"'
								cli_media_type = 'show media interface te ' + str(slot) + '/0/' + str(port) + ' | i Name | exclude Vendor'
								cli_media_transceiver = 'show media interface te ' + str(slot) + '/0/' + str(port) + ' | i Transceiver'
								cli_description = 'show interface te ' + str(slot) + '/0/' + str(port) + ' | i Description'

								# Sending Command(s)
								cli_check_state = self.connection.send_command(cli_state)
								cli_check_speed = self.connection.send_command(cli_speed)
								cli_check_media_type = self.connection.send_command(cli_media_type)
								cli_check_transceiver = self.connection.send_command(cli_media_transceiver)
								cli_check_description = self.connection.send_command(cli_description)

								# For populating report about sfp type, LX, SX, UTP, LR, SR
								# Multimode
								if 'sw' in cli_check_media_type[17:]:
									if '10_GB' in cli_check_transceiver:
										sfp_type = '10G-SFP-SR'
									elif '1_GB' in cli_check_transceiver:
										sfp_type = '1G-SFP-SX'
									else:
										sfp_type = 'MM - NOT DETECTED'
								# Monomode
								elif 'lw' in cli_check_media_type[17:]:
									if '10_GB' in cli_check_transceiver:
										sfp_type = '10G-SFP-LR'
									elif '1_GB' in cli_check_transceiver:
										sfp_type = '1G-SFP-LX'
									else:
										sfp_type = 'SM - NOT DETECTED'
								# Base T or Direct Attach
								elif 'cu' in cli_check_media_type[17:]:
									if port <= 44:
										sfp_type = 'UTP'
									else:
										sfp_type = 'DIRECT ATTACH'
								# EMPTY
								elif '' in cli_check_media_type:
									sfp_type = 'EMPTY'
								# UNKNOWN
								else:
									sfp_type = 'NOT DETECTED'

								# Populating Report, skipping invalid or DOWN interfaces
								if 'admin down' in cli_check_state:
									output_log.write(
										check_model[str(slot)] +
										';' +
										self.device['host'].upper() +
										';' +
										'Te' +
										str(slot) +
										'/0/' +
										str(port) +
										';' +
										'DOWN(ADMIN)' +
										';' +
										sfp_type +
										';' +
										'N/A' +
										';' +
										cli_check_description[13:] +
										'\n'
									)
									continue
								elif 'protocol is up (connected)' not in cli_check_state:
									output_log.write(
										check_model[str(slot)] +
										';' +
										self.device['host'].upper() +
										';' +
										'Te' +
										str(slot) +
										'/0/' +
										str(port) +
										';' +
										'DOWN' +
										';' +
										sfp_type +
										';' +
										'N/A' +
										';' +
										cli_check_description[13:] +
										'\n'
									)
									continue

								# Populating Report 10GB = HOSTNAME;HARDWARE MODEL;IF STATUS;IF;MEDIA;SPEED;DESCRIPTION
								elif 'protocol is up (connected)' in cli_check_state:
									if '100 Mbit' in cli_check_speed:
										output_log.write(
											check_model[str(slot)] +
											';' +
											self.device['host'].upper() +
											';' +
											'Te' +
											str(slot) +
											'/0/' + str(port) +
											';' +
											'UP' +
											';' +
											sfp_type +
											';' +
											'100Mbps' +
											';' +
											cli_check_description[13:] +
											'\n'
										)
									elif '1000 Mbit' in cli_check_speed:
										output_log.write(
											check_model[str(slot)] +
											';' +
											self.device['host'].upper() +
											';' +
											'Te' +
											str(slot) +
											'/0/' +
											str(port) +
											';' +
											'UP' +
											';' +
											sfp_type +
											';' +
											'1Gbps' +
											';' +
											cli_check_description[13:] +
											'\n'
										)
									elif '10000 Mbit' in cli_check_speed:
										output_log.write(
											check_model[str(slot)] +
											';' +
											self.device['host'].upper() +
											';' +
											'Te' +
											str(slot) +
											'/0/' +
											str(port) +
											';' +
											'UP' +
											';' +
											sfp_type +
											';' +
											'10Gbps' +
											';' +
											cli_check_description[13:] +
											'\n'
										)
									else:
										output_log.write(
											check_model[str(slot)] +
											';' +
											self.device['host'].upper() +
											';' +
											'Te' +
											str(slot) +
											'/0/' +
											str(port) +
											';' +
											'UP' +
											';' +
											sfp_type +
											';' +
											'ND' +
											';' +
											cli_check_description[13:] +
											'\n'
										)

								# UNKNOWN Section
								else:
									print(
										self.device['host'].upper() +
										' Port ' +
										str(slot) +
										'/0/' +
										str(port) +
										':{}'.format(str(color.prRed(' is Down or Media Type Not Detected!')))
									)
									output_log.write(
										check_model[str(slot)] +
										';' +
										self.device['host'].upper() +
										';' +
										';' +
										'Te' +
										str(slot) +
										'/0/' +
										str(port) +
										'DOWN or ND' +
										';' +
										sfp_type +
										';' +
										'N/A' +
										';' +
										cli_check_description[13:] +
										'\n'
									)

							# 40GB Normal and Breakout interfaces
							# 40GB Normal interfaces
							for port in range(97, 109):

								# Call after consuming one item, bar progress
								bar()

								# Variables for Command(s)
								cli_state = 'show interface fo ' + str(slot) + '/0/' + str(port) + ' | i protocol'
								cli_media_type = 'show media interface fo ' + str(slot) + '/0/' + str(port) + ' | i Name | exclude Vendor'
								cli_media_transceiver = 'show media interface fo ' + str(slot) + '/0/' + str(port) + ' | i Transceiver'
								cli_description = 'show interface fo ' + str(slot) + '/0/' + str(port) + ' | i Description'

								# Sending Command(s)
								cli_check_state = self.connection.send_command(cli_state)
								cli_check_media_type = self.connection.send_command(cli_media_type)
								cli_check_transceiver = self.connection.send_command(cli_media_transceiver)
								cli_check_description = self.connection.send_command(cli_description)

								# For populating report about sfp type, 40GB
								# Multimode
								if 'id' in cli_check_media_type[17:]:
									if '40_GB/s  Short_dist' in cli_check_transceiver:
										sfp_type = '40G-QSFP - DIRECT ATTACH OR 4x10GB BREAKOUT'
									else:
										sfp_type = 'MM 40GB - NOT DETECTED'
								# EMPTY
								elif '' in cli_check_media_type:
									sfp_type = 'EMPTY'
								# UNKNOWN
								else:
									sfp_type = 'NOT DETECTED'

								# Populating Report, skipping invalid or DOWN interfaces
								if "doesn't exist" in cli_check_state:
									output_log.write(
										check_model[str(slot)] +
										';' +
										self.device['host'].upper() +
										';' +
										'Fo' +
										str(slot) +
										'/0/' +
										str(port) +
										';' +
										'ND' +
										';' +
										'ND' +
										';' +
										'ND' +
										';' +
										'ND' +
										'\n'
									)
									continue
								elif 'admin down' in cli_check_state:
									output_log.write(
										check_model[str(slot)] +
										';' +
										self.device['host'].upper() +
										';' +
										'Fo' +
										str(slot) +
										'/0/' +
										str(port) +
										';' +
										'DOWN(ADMIN)' +
										';' +
										sfp_type +
										';' +
										'40Gbps' +
										';' +
										cli_check_description[13:] +
										'\n'
									)

								elif 'protocol is up (connected)' not in cli_check_state:
									output_log.write(
										check_model[str(slot)] +
										';' +
										self.device['host'].upper() +
										';' +
										'Fo' +
										str(slot) +
										'/0/' +
										str(port) +
										';' +
										'DOWN' +
										';' +
										sfp_type +
										';' +
										'40Gbps' +
										';' +
										cli_check_description[13:] +
										'\n'
									)
									continue

								# Populating Report = HOSTNAME;HARDWARE MODEL;IF STATUS;IF;MEDIA;SPEED;DESCRIPTION
								elif 'protocol is up (connected)' in cli_check_state:
									output_log.write(
										check_model[str(slot)] +
										';' +
										self.device['host'].upper() +
										';' +
										'Fo' +
										str(slot) +
										'/0/' +
										str(port) +
										';' +
										'UP' +
										';' +
										sfp_type +
										';' +
										'40Gbps' +
										';' +
										cli_check_description[13:] +
										'\n'
									)

								# UNKNOWN Section
								else:
									print(
										self.device['host'].upper() +
										' Port ' +
										str(slot) +
										'/0/' +
										str(port) +
										':{}'.format(str(color.prRed(' is Down or Media Type Not Detected!'))))
									output_log.write(
										check_model[str(slot)] +
										';' +
										self.device['host'].upper() +
										';' +
										';' +
										'Fo' +
										str(slot) +
										'/0/' +
										str(port) +
										'DOWN or ND' +
										';' +
										sfp_type +
										';' +
										'N/A' +
										';' +
										cli_check_description[13:] +
										'\n'
									)

							# Looping trough interfaces 100GB
							# Detecting if we have 100GB interfaces converted
							if sum_interfaces_100gb > 0:

								# Looping trough interfaces 100GB
								# 100GB Section Group 1
								for port in range(97, 99):

									# Call after consuming one item, bar progress
									bar()

									# Variables for Command(s)
									cli_state = 'show interface hu ' + str(slot) + '/0/' + str(port) + ' | i protocol'
									cli_media_type = 'show media interface hu ' + str(slot) + '/0/' + str(port) + ' | i Name | exclude Vendor'
									cli_media_transceiver = 'show media interface hu ' + str(slot) + '/0/' + str(port) + ' | i Transceiver'
									cli_description = 'show interface hu ' + str(slot) + '/0/' + str(port) + ' | i Description'

									# Sending Command(s)
									cli_check_state = self.connection.send_command(cli_state)
									cli_check_media_type = self.connection.send_command(cli_media_type)
									cli_check_transceiver = self.connection.send_command(cli_media_transceiver)
									cli_check_description = self.connection.send_command(cli_description)

									# For populating report about sfp type, 40GB
									# Multimode
									if 'id' in cli_check_media_type[17:]:
										if '100_GB' in cli_check_transceiver:
											sfp_type = '100GBASE-LR4 QSFP28'
										else:
											sfp_type = 'SM 100GB - NOT DETECTED'
									# EMPTY
									elif '' in cli_check_media_type:
										sfp_type = 'EMPTY'
									# UNKNOWN
									else:
										sfp_type = 'NOT DETECTED'

									if 'admin down' in cli_check_state:
										output_log.write(
											check_model[str(slot)] +
											';' +
											self.device['host'].upper() +
											';' +
											'Hu' +
											str(slot) +
											'/0/' +
											str(port) +
											';' +
											'DOWN(ADMIN)' +
											';' +
											sfp_type +
											';' +
											'100Gbps' +
											';' +
											cli_check_description[13:] +
											'\n'
										)
										continue

									elif 'protocol is up (connected)' not in cli_check_state:
										output_log.write(
											check_model[str(slot)] +
											';' +
											self.device['host'].upper() +
											';' +
											'Hu' +
											str(slot) +
											'/0/' +
											str(port) +
											';' +
											'DOWN' +
											';' +
											sfp_type +
											';' +
											'100Gbps' +
											';' +
											cli_check_description[13:] +
											'\n'
										)
										continue

									# Populating Report = HOSTNAME;HARDWARE MODEL;IF STATUS;IF;MEDIA;SPEED;DESCRIPTION
									elif 'protocol is up (connected)' in cli_check_state:
										output_log.write(
											check_model[str(slot)] +
											';' +
											self.device['host'].upper() +
											';' +
											'Hu' +
											str(slot) +
											'/0/' +
											str(port) +
											';' +
											'UP' +
											';' +
											sfp_type +
											';' +
											'100Gbps' +
											';' +
											cli_check_description[13:] +
											'\n'
										)

									# UNKNOWN Section
									else:
										print(
											self.device['host'].upper() +
											' Port ' +
											str(slot) +
											'/0/' +
											str(port) +
											':{}'.format(str(color.prRed(' is Down or Media Type Not Detected!'))))
										output_log.write(
											check_model[str(slot)] +
											';' +
											self.device['host'].upper() +
											';' +
											';' +
											'Hu' +
											str(slot) +
											'/0/' +
											str(port) +
											'DOWN or ND' +
											';' +
											sfp_type +
											';' +
											'100Gbps' +
											';' +
											cli_check_description[13:] +
											'\n'
										)

								# 100GB Section Group 2
								for port in range(103, 105):

									# Call after consuming one item, bar progress
									bar()

									# Variables for Command(s)
									cli_state = 'show interface hu ' + str(slot) + '/0/' + str(port) + ' | i protocol'
									cli_media_type = 'show media interface hu ' + str(slot) + '/0/' + str(port) + ' | i Name | exclude Vendor'
									cli_media_transceiver = 'show media interface hu ' + str(slot) + '/0/' + str(port) + ' | i Transceiver'
									cli_description = 'show interface hu ' + str(slot) + '/0/' + str(port) + ' | i Description'

									# Sending Command(s)
									cli_check_state = self.connection.send_command(cli_state)
									cli_check_media_type = self.connection.send_command(cli_media_type)
									cli_check_transceiver = self.connection.send_command(cli_media_transceiver)
									cli_check_description = self.connection.send_command(cli_description)

									# For populating report about sfp type, 40GB
									# Multimode
									if 'id' in cli_check_media_type[17:]:
										if '100_GB' in cli_check_transceiver:
											sfp_type = '100GBASE-LR4 QSFP28'
										else:
											sfp_type = 'SM 100GB - NOT DETECTED'
									# EMPTY
									elif '' in cli_check_media_type:
										sfp_type = 'EMPTY'
									# UNKNOWN
									else:
										sfp_type = 'NOT DETECTED'

									if 'admin down' in cli_check_state:
										output_log.write(
											check_model[str(slot)] +
											';' +
											self.device['host'].upper() +
											';' +
											'Hu' +
											str(slot) +
											'/0/' +
											str(port) +
											';' +
											'DOWN(ADMIN)' +
											';' +
											sfp_type +
											';' +
											'100Gbps' +
											';' +
											cli_check_description[13:] +
											'\n'
										)
										continue

									elif 'protocol is up (connected)' not in cli_check_state:
										output_log.write(
											check_model[str(slot)] +
											';' +
											self.device['host'].upper() +
											';' +
											'Hu' +
											str(slot) +
											'/0/' +
											str(port) +
											';' +
											'DOWN' +
											';' +
											sfp_type +
											';' +
											'100Gbps' +
											';' +
											cli_check_description[13:] +
											'\n'
										)
										continue

									# Populating Report = HOSTNAME;HARDWARE MODEL;IF STATUS;IF;MEDIA;SPEED;DESCRIPTION
									elif 'protocol is up (connected)' in cli_check_state:
										output_log.write(
											check_model[str(slot)] +
											';' +
											self.device['host'].upper() +
											';' +
											'Hu' +
											str(slot) +
											'/0/' +
											str(port) +
											';' +
											'UP' +
											';' +
											sfp_type +
											';' +
											'100Gbps' +
											';' +
											cli_check_description[13:] +
											'\n'
										)

									# UNKNOWN Section
									else:
										print(
											self.device['host'].upper() +
											' Port ' +
											str(slot) +
											'/0/' +
											str(port) +
											':{}'.format(str(color.prRed(' is Down or Media Type Not Detected!'))))
										output_log.write(
											check_model[str(slot)] +
											';' +
											self.device['host'].upper() +
											';' +
											';' +
											'Hu' +
											str(slot) +
											'/0/' +
											str(port) +
											'DOWN or ND' +
											';' +
											sfp_type +
											';' +
											'100Gbps' +
											';' +
											cli_check_description[13:] +
											'\n'
										)

							else:
								print("This is the last else, something is wrong, please verify !")

			else:
				pass

			if not automation:
				# Inform user about report file
				print('#' * 126)
				print('   Your file report was save on: {0}'.format(dir_report))
				print('   With this name: {0}'.format(output_log.name))
				print('#' * 126)

			if not automation:
				# Closing Log File
				aux.make_output_log_file('close', output_log)

			# Closing connection
			# self.connection.disconnect()

			return 'OK'

		except Exception as e:
			print('\n{}'.format(
				str(color.prRed('*****--------------------<<<<<<<<<< BEGIN >>>>>>>>>>--------------------*****')))
			)
			print("Oops!", sys.exc_info()[0], " in ", self.device['host'].upper(), "occurred.")
			for erro in sys.exc_info():
				print(erro)
			print(
				type(e).__name__,  # Type of Error
				__file__,  # File Path
				e.__traceback__.tb_lineno  # Line Error
			)
			output_log.write(
				'N/A' +
				';' +
				self.device['host'].upper() +
				';' + 'Can\'t login in this hostname!!! Error ---> ' +
				str(sys.exc_info()[0]) +
				';' +
				'N/A' +
				';' +
				'N/A' +
				';' +
				'N/A' +
				';' +
				'N/A\n'
				)
			print('{}'.format(
				str(color.prRed('*****--------------------<<<<<<<<<< *END* >>>>>>>>>>--------------------*****\n')))
			)

			return 'NOK'

	def make_report_snmp_syslog(self, vendor, output_log='', automation=False):
		"""
		1 - Connect in element.
		2 - Select type of element (Extreme, Brocade, HP, and so on).
		3 - Create .csv file with information ...

		Parameters
		----------
			vendor : str
				Help for identify commands
			output_log: io.TextIOWrapper
				Archive for store report in case of automation
			automation: boolean
				For identify main function of execution, only one report (=False) or N reports (=True)

		Returns
		-------
		str
		"""

		# Main Try/Except Block
		try:

			# Instance of Auxiliary class
			aux = Auxiliary(self.device, self.connection)

			if not automation:
				# Making Report Directory
				aux.make_report_directory()
				# Creating .csv log file
				output_log = aux.make_output_log_file('open')[0]

			# Commands to Check SNMP and SYSLOG pre configured servers
			if vendor == 'Brocade':
				cli_check_snmp = 'show running-config | i "snmp-server host"'
				cli_check_syslog = 'show running-config | i "syslog-server"'
			elif vendor == 'HP':
				cli_check_snmp = 'display current-configuration | i target-host'
				cli_check_syslog = 'display current-configuration | i info-center'
			elif vendor == 'Extreme':
				cli_check_snmp = 'show configuration | i v1v2cNotifyTAddr'
				cli_check_syslog = 'show configuration | i configure log target syslog'
			elif (vendor == 'Cisco') and (self.device['device_type'] == 'cisco_nxos'):
				cli_check_snmp = 'show run | i "snmp-server host"'
				cli_check_syslog = 'show run | i "logging server"'
			elif vendor == 'Cisco':
				cli_check_snmp = 'show run | i snmp-server'
				cli_check_syslog = 'show run | i logging'
			elif vendor == 'Datacom':
				cli_check_snmp = 'show running-config | i version'
				cli_check_syslog = 'show running-config | i logging'
			elif vendor == 'Ruckus':
				cli_check_snmp = 'show running-config | i snmp-server host'
				cli_check_syslog = 'show running-config | i logging host'
			else:
				cli_check_snmp = ''
				cli_check_syslog = ''

			# Sending Command(s)
			# Retrieving commands
			cli_command_snmp = self.connection.send_command(cli_check_snmp)
			cli_command_syslog = self.connection.send_command(cli_check_syslog)

			# Populating Report
			server_num = 0
			for snmp_server in cli_command_snmp.splitlines():
				server_num += 1
				output_log.write(
					vendor.upper() +
					';' +
					str(self.device['host']) +
					';' +
					'SNMP Server: ' +
					str(server_num) +
					';' +
					snmp_server +
					'\n'
				)

			server_num = 0
			for syslog_server in cli_command_syslog.splitlines():
				server_num += 1
				output_log.write(
					vendor.upper() +
					';' +
					str(self.device['host']) +
					';' +
					'SYSLOG Server: ' +
					str(server_num) +
					';' +
					syslog_server +
					'\n'
				)

			if not automation:
				# Closing Log File
				aux.make_output_log_file('close', output_log)

			# Closing connection
			# connection.disconnect()

			return 'OK'

		except Exception as e:
			print('\n{}'.format(
				str(color.prRed('*****--------------------<<<<<<<<<< BEGIN >>>>>>>>>>--------------------*****')))
			)
			print("Oops!", sys.exc_info()[0], " in ", self.device['host'].upper(), "occurred.")
			for erro in sys.exc_info():
				print(erro)
			print(
				type(e).__name__,  # Type of Error
				__file__,  # File Path
				e.__traceback__.tb_lineno  # Line Error
			)
			output_log.write(
				'N/A' +
				';' +
				self.device['host'].upper() +
				';' + 'Can\'t login in this hostname!!! Error ---> ' +
				str(sys.exc_info()[0]) +
				';' +
				'N/A' +
				';' +
				'N/A' +
				';' +
				'N/A' +
				';' +
				'N/A\n'
				)
			print('{}'.format(
				str(color.prRed('*****--------------------<<<<<<<<<< *END* >>>>>>>>>>--------------------*****\n')))
			)

			return 'NOK'
